# 企业名片系统图片与富文本存储方案

## 需求背景

企业名片系统需要支持多种图片和富文本的上传和编辑，考虑到服务器带宽限制（5Mbps）和用户体验，需要设计高效的存储和分发方案。

## 存储策略分析

### 数据库存储

**优点**：
- 方便管理和查询，特别是对小型图片和短文本
- 数据库备份时会同时备份所有内容
- 适合小型项目快速部署，不需额外配置文件服务器

**缺点**：
- 增加数据库大小，影响性能和备份恢复时间
- 对大文件（高分辨率图片）不友好
- 在5Mbps带宽下载大型二进制内容会显著影响性能

### 文件系统存储

**优点**：
- 更适合大文件存储
- 可以利用文件系统优化（缓存、压缩等）
- 数据库只存储文件路径，保持数据库轻量

**缺点**：
- 需要管理文件路径和清理无用文件
- 备份需要单独处理文件和数据库

## CDN使用分析

在5Mbps带宽环境下：
- 不使用CDN：所有访问者共享有限带宽，导致加载缓慢
- 使用CDN：将静态资源分发到离用户最近的服务器，大幅提升访问速度，减轻源服务器负担

## 成熟企业的解决方案

### 主流解决方案

1. **云存储 + CDN**：
   - 阿里云：OSS对象存储 + CDN加速
   - 腾讯云：COS云对象存储 + CDN
   - AWS：S3存储 + CloudFront CDN
   - 七牛云：对象存储 + CDN（国内中小企业常用）

2. **分离存储策略**：
   - 小型图片（头像/图标）：可选择存数据库或文件系统
   - 大型图片/媒体文件：存储在对象存储
   - 富文本：HTML内容存数据库，图片引用外部存储

### 图片处理流程

- 上传时自动生成多种尺寸版本（原图/中等/缩略图）
- 图片压缩优化（WebP格式转换）
- 内容分发自动推送到CDN

## 推荐方案

### 混合存储策略

- **小图片和短富文本**（<100KB）：存储在数据库中
- **大图片和长富文本**：存储为文件，数据库仅保存路径

### 图片优化处理

- 统一将图片编码为最大1K分辨率的WebP格式
- WebP比JPEG小约25-30%，比PNG小约26%，同时保持相似的图像质量
- 固定分辨率上限（1000px）确保系统一致性
- 为不支持WebP的浏览器提供JPEG回退方案

### CDN集成

- 所有优化后的图片自动同步到CDN
- 使用CDN URL代替本地文件路径
- 设置适当的缓存策略，确保资源及时更新

### 文件组织结构

- 采用`/static/企业ID/年月/文件名`的方式组织文件
- 为每个文件生成唯一ID，避免文件名冲突

## 开发阶段CDN模拟方案

### CDN抽象层设计

```go
// CDN服务接口
type CDNService interface {
    Upload(file []byte, filename string) (string, error)
    Delete(filename string) error
}

// 本地开发实现
type LocalCDNService struct {
    basePath string
}

func (l *LocalCDNService) Upload(file []byte, filename string) (string, error) {
    // 保存到本地static/cdn目录
    path := filepath.Join("static", "cdn", filename)
    err := ioutil.WriteFile(path, file, 0644)
    if err != nil {
        return "", err
    }
    return fmt.Sprintf("http://localhost:23355/cdn/%s", filename), nil
}

// 生产CDN实现
type ProductionCDNService struct {
    // CDN SDK配置
}

// 工厂函数根据环境返回适当的实现
func NewCDNService() CDNService {
    if config.AppConfig.IsDev {
        return &LocalCDNService{basePath: "./static/cdn"}
    }
    return &ProductionCDNService{/* 配置生产CDN */}
}
```

### 配置文件区分环境

```go
// config/config.go 中添加
type AppConfig struct {
    // 现有配置...
    CDNBasePath string // CDN基础路径
    IsDev       bool   // 是否开发环境
}

// 根据环境设置CDN路径
if config.AppConfig.IsDev {
    config.AppConfig.CDNBasePath = "http://localhost:23355/cdn/"
} else {
    config.AppConfig.CDNBasePath = "https://your-cdn.com/"
}
```

### 静态文件服务配置

```go
// 在开发配置中添加静态文件服务
func setupDevRoutes(r *gin.Engine) {
    // 静态文件服务，模拟CDN
    r.Static("/cdn", "./static")
}
```

## 菜单内容存储设计

企业名片系统中，每个菜单项都需要存储多种数据（多个图片、富文本等）。为此，我们设计了以下数据架构：

### 数据模型设计

```go
// MenuSection 菜单项定义
type MenuSection struct {
    BaseModel
    Code        string `gorm:"size:50;uniqueIndex;not null" json:"code"` // 如home, about, products
    Name        string `gorm:"size:50;not null" json:"name"`             // 显示名称
    SortOrder   int    `gorm:"default:0" json:"sort_order"`
    IsActive    bool   `gorm:"default:true" json:"is_active"`
    Description string `gorm:"size:255" json:"description"`
}

// SectionContent 菜单内容关联表
type SectionContent struct {
    BaseModel
    EnterpriseID uint   `gorm:"index;not null" json:"enterprise_id"`
    SectionCode  string `gorm:"size:50;not null;index" json:"section_code"` // 关联MenuSection.Code
    ContentType  string `gorm:"size:20;not null" json:"content_type"`       // text, rich_text, image, video, 3d
    ContentKey   string `gorm:"size:50;not null" json:"content_key"`        // 内容键名如banner, intro_text
    Title        string `gorm:"size:100" json:"title"`                     // 可选标题
    SortOrder    int    `gorm:"default:0" json:"sort_order"`                // 排序
    
    // 内容存储 (三选一)
    TextContent  string `gorm:"type:text" json:"text_content"`        // 存储短文本
    ResourceID   *uint  `json:"resource_id"`                          // 关联到ResourceFile
    
    // 关联
    Enterprise  Enterprise   `gorm:"foreignKey:EnterpriseID" json:"-"`
    Resource    ResourceFile `gorm:"foreignKey:ResourceID" json:"resource,omitempty"`
}

// ResourceFile 资源文件表
type ResourceFile struct {
    BaseModel
    EnterpriseID uint   `gorm:"index" json:"enterprise_id"`
    Type         string `gorm:"size:20;not null" json:"type"` // image, document, rich_text
    StorageType  string `gorm:"size:10;not null" json:"storage_type"` // db, file, cdn
    FileName     string `gorm:"size:255" json:"file_name"`
    FileSize     int64  `json:"file_size"`
    MimeType     string `gorm:"size:100" json:"mime_type"`
    FilePath     string `gorm:"size:512" json:"file_path"` // 相对路径或CDN URL
    Content      []byte `gorm:"type:blob" json:"-"` // 小文件直接存储内容
    Metadata     string `gorm:"type:json" json:"metadata"` // 宽高、压缩参数等JSON元数据
    HashCode     string `gorm:"size:64;index" json:"hash_code"` // 文件内容哈希，用于去重
}
```

### 服务层设计

```go
// MenuContentService 菜单内容服务
type MenuContentService struct {
    db *gorm.DB
    cdnService CDNService
    resourceService ResourceService
}

// GetSectionContents 获取指定企业的菜单项内容
func (s *MenuContentService) GetSectionContents(ctx context.Context, enterpriseID uint, sectionCode string) ([]SectionContent, error) {
    var contents []SectionContent
    err := s.db.Preload("Resource").Where("enterprise_id = ? AND section_code = ?", enterpriseID, sectionCode).
           Order("sort_order ASC").Find(&contents).Error
    return contents, err
}

// SaveContent 保存菜单内容(支持文本或资源)
func (s *MenuContentService) SaveContent(ctx context.Context, content *SectionContent) error {
    // 根据ContentType决定保存策略
    if content.ContentType == "text" || content.ContentType == "rich_text" && len(content.TextContent) < 1024 {
        // 短文本直接保存到SectionContent表
        return s.db.Save(content).Error
    } else if content.ResourceID != nil {
        // 资源ID已存在，直接保存关联
        return s.db.Save(content).Error
    } else {
        // 需要先创建资源记录
        return errors.New("resource required but not provided")
    }
}
```

### 控制器设计

```go
// UploadSectionResource 上传菜单资源
func (c *MenuContentController) UploadSectionResource(ctx *gin.Context) {
    enterpriseID := getCurrentEnterpriseID(ctx)
    sectionCode := ctx.PostForm("section_code")
    contentKey := ctx.PostForm("content_key")
    contentType := ctx.PostForm("content_type")
    
    file, header, err := ctx.Request.FormFile("file")
    if err != nil {
        BadRequest(ctx, "文件上传失败")
        return
    }
    defer file.Close()
    
    // 处理文件上传
    resource, err := c.contentService.resourceService.SaveResource(ctx, file, header, enterpriseID)
    if err != nil {
        InternalServerError(ctx, "资源保存失败")
        return
    }
    
    // 创建或更新内容关联
    content := &SectionContent{
        EnterpriseID: enterpriseID,
        SectionCode:  sectionCode,
        ContentType:  contentType,
        ContentKey:   contentKey,
        ResourceID:   &resource.ID,
    }
    
    if err := c.contentService.SaveContent(ctx, content); err != nil {
        InternalServerError(ctx, "内容保存失败")
        return
    }
    
    Success(ctx, gin.H{
        "message": "资源上传成功",
        "content": content,
    })
}
```

### 前端数据组织

菜单数据组织方式示例：

```json
{
  "home": {
    "banner": {
      "type": "image",
      "url": "https://cdn.example.com/images/123.webp"
    },
    "intro_text": {
      "type": "rich_text",
      "content": "<p>公司简介内容...</p>"
    }
  },
  "about": {
    "company_intro": {
      "type": "rich_text",
      "content": "<h2>公司介绍</h2><p>详细内容...</p>"
    },
    "team_photos": [
      {
        "type": "image",
        "url": "https://cdn.example.com/images/team1.webp",
        "title": "管理团队"
      },
      {
        "type": "image",
        "url": "https://cdn.example.com/images/team2.webp",
        "title": "技术团队"
      }
    ]
  }
}
```

## 图片处理与资源上传流程

1. 前端上传图片到后端API
2. 后端处理图片（转换为WebP、压缩到1K分辨率）
3. 处理后的图片保存到本地文件系统或直接上传到CDN
4. 创建ResourceFile记录存储文件元信息
5. 创建SectionContent记录关联菜单项与资源
6. 返回资源URL给前端展示

## 实施步骤

1. 设计并实现资源表（ResourceFile）和菜单内容表（MenuSection, SectionContent）
2. 添加文件上传控制器，处理不同类型内容
3. 实现图片处理中间件，自动转换为WebP格式
4. 集成CDN服务接口，支持开发和生产环境
5. 设计菜单内容管理API，实现内容的增删改查
6. 更新企业名片相关接口，使用新的存储方案

## 总结

通过混合存储策略、图片优化和CDN分发，企业名片系统可以在有限带宽条件下提供良好的用户体验。采用基于菜单项的内容组织方式，使系统具有良好的扩展性和维护性。在开发阶段使用本地静态文件服务模拟CDN，可以确保从开发到生产的平滑过渡。
