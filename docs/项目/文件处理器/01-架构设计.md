# 架构设计

## 设计原则

### 1. 单一职责原则

- 每层只负责自己的职责
- 业务层不关心工具实现
- 工具层不关心业务逻辑

### 2. 开闭原则

- 对扩展开放：添加新文件类型只需实现新处理器
- 对修改关闭：不需要修改现有代码

### 3. 依赖倒置原则

- 业务层依赖接口，不依赖具体实现
- 工具层可以独立测试和替换

## 目录结构

```
services/fileprocessor/
├── processor.go                    # 处理器接口定义
├── file_processor_service.go      # 统一服务入口
├── types.go                        # 通用类型定义
├── config.go                       # 配置
└── processors/
    ├── image_processor.go         # 图片处理器
    ├── video_processor.go         # 视频处理器
    ├── document_processor.go      # 文档处理器
    ├── model_processor.go         # 3D模型处理器
    └── archive_processor.go       # 压缩包处理器

services/task/
├── task_service.go                # 任务服务
├── task_queue.go                  # 任务队列
├── task_executor.go               # 任务执行器
├── task_recovery.go               # 任务恢复
└── task_notifier.go               # 任务通知

utils/
├── video/
│   └── ffmpeg.go                  # FFmpeg 工具封装
├── image/
│   └── imagemagick.go             # ImageMagick 工具封装
├── document/
│   └── pdf.go                     # PDF 工具封装
└── model/
    └── assimp.go                  # Assimp 工具封装

models/
└── task.go                        # 任务数据模型
```

## 核心接口

### FileProcessor 接口

```go
// FileProcessor 文件处理器接口
type FileProcessor interface {
    // Support 检查是否支持该文件格式
    Support(format string) bool

    // ExtractMetadata 提取文件元数据
    ExtractMetadata(filePath string) (*FileMetadata, error)

    // GeneratePreview 生成预览图
    GeneratePreview(filePath string, options PreviewOptions) (*PreviewResult, error)

    // GenerateThumbnail 生成缩略图
    GenerateThumbnail(filePath string, options ThumbnailOptions) (string, error)

    // Convert 格式转换（可选）
    Convert(filePath string, options ConvertOptions) (string, error)

    // Validate 验证文件完整性（可选）
    Validate(filePath string) error

    // Name 获取处理器名称
    Name() string
}
```

## 数据流

### 同步处理流程

```
用户请求
    ↓
FileProcessorService.ExtractMetadata()
    ↓
GetProcessor(format) → 选择处理器
    ↓
VideoProcessor.ExtractMetadata()
    ↓
FFmpeg.ExtractMetadata() → 调用工具
    ↓
解析输出 → 返回元数据
    ↓
返回给用户
```

### 异步处理流程

```
用户请求
    ↓
TaskService.CreateTask() → 创建任务
    ↓
TaskQueue.Push() → 加入队列
    ↓
TaskExecutor.Execute() → 执行任务
    ↓
选择处理器 → 调用工具
    ↓
进度回调 → 更新数据库
    ↓
完成通知 → 通知用户
```

## 扩展点

### 1. 添加新文件类型

```go
// 1. 实现 FileProcessor 接口
type AudioProcessor struct {
    ffmpeg *video.FFmpeg
}

func (p *AudioProcessor) Support(format string) bool {
    return format == "mp3" || format == "wav"
}

// 2. 注册到服务
service.RegisterProcessor(NewAudioProcessor())
```

### 2. 添加新工具

```go
// 1. 封装工具
type SomeToolWrapper struct {
    binPath string
}

func (t *SomeToolWrapper) DoSomething() error {
    cmd := exec.Command(t.binPath, args...)
    return cmd.Run()
}

// 2. 在处理器中使用
type SomeProcessor struct {
    tool *SomeToolWrapper
}
```

### 3. 添加新任务类型

```go
// 1. 定义任务类型
const TaskTypeAudioConvert = "audio_convert"

// 2. 在执行器中处理
func (e *TaskExecutor) Execute(ctx context.Context, taskCtx *TaskContext) error {
    switch task.Type {
    case TaskTypeAudioConvert:
        return e.executeAudioConvert(ctx, taskCtx)
    }
}
```

## 配置管理

### 配置文件

```yaml
# configs/fileprocessor.yaml
fileprocessor:
  # 工具配置
  ffmpeg:
    bin_path: "ffmpeg"
    timeout: 300

  imagemagick:
    bin_path: "convert"
    timeout: 60

  # 任务配置
  task:
    max_concurrent: 5 # 最大并发数
    max_retries: 3 # 最大重试次数
    retry_delay: 60 # 重试延迟（秒）
    cleanup_after: 86400 # 清理时间（秒）

  # 资源限制
  resource:
    max_memory_per_task: 2147483648 # 2GB
    max_cpu_percent: 80.0
    max_temp_size: 10737418240 # 10GB
```

### 配置加载

```go
type Config struct {
    FFmpeg      FFmpegConfig
    ImageMagick ImageMagickConfig
    Task        TaskConfig
    Resource    ResourceConfig
}

func LoadConfig() (*Config, error) {
    // 从文件加载
    // 支持环境变量覆盖
    // 支持默认值
}
```

## 错误处理

### 错误类型

```go
// 工具错误
type ToolError struct {
    Tool    string
    Command string
    Output  string
    Err     error
}

// 任务错误
type TaskError struct {
    TaskID  uint
    Type    string
    Message string
    Err     error
}

// 资源错误
type ResourceError struct {
    Resource string
    Limit    int64
    Current  int64
}
```

### 错误处理策略

1. **工具错误**: 记录详细日志，返回友好错误信息
2. **任务错误**: 标记任务失败，支持重试
3. **资源错误**: 拒绝任务，等待资源释放

## 性能考虑

### 1. 并发控制

```go
type TaskExecutor struct {
    semaphore chan struct{} // 限制并发数
}

func (e *TaskExecutor) Execute(ctx context.Context, task *Task) error {
    // 获取信号量
    e.semaphore <- struct{}{}
    defer func() { <-e.semaphore }()

    // 执行任务
}
```

### 2. 资源监控

```go
type ResourceMonitor struct {
    cpuUsage    float64
    memoryUsage int64
    diskUsage   int64
}

func (m *ResourceMonitor) CanExecute(task *Task) bool {
    // 检查资源是否充足
}
```

### 3. 缓存优化

```go
type MetadataCache struct {
    cache map[string]*FileMetadata
    ttl   time.Duration
}

func (c *MetadataCache) Get(filePath string) (*FileMetadata, bool) {
    // 从缓存获取
}
```

## 安全考虑

### 1. 路径安全

```go
func ValidatePath(path string) error {
    // 防止路径遍历
    if strings.Contains(path, "..") {
        return errors.New("invalid path")
    }

    // 检查路径是否在允许的目录内
    absPath, _ := filepath.Abs(path)
    if !strings.HasPrefix(absPath, allowedDir) {
        return errors.New("path not allowed")
    }
}
```

### 2. 命令注入防护

```go
func SanitizeInput(input string) string {
    // 移除危险字符
    dangerous := []string{";", "&", "|", "`", "$", "(", ")"}
    for _, char := range dangerous {
        input = strings.ReplaceAll(input, char, "")
    }
    return input
}
```

### 3. 资源限制

```go
// 限制单个任务的资源使用
cmd := exec.Command(...)
cmd.SysProcAttr = &syscall.SysProcAttr{
    // 设置资源限制
}
```

## 测试策略

### 1. 单元测试

```go
func TestVideoProcessor_ExtractMetadata(t *testing.T) {
    // Mock FFmpeg
    mockFFmpeg := &MockFFmpeg{}
    processor := NewVideoProcessor(mockFFmpeg)

    // 测试
    metadata, err := processor.ExtractMetadata("test.mp4")
    assert.NoError(t, err)
    assert.Equal(t, 1920, metadata.Width)
}
```

### 2. 集成测试

```go
func TestFileProcessorService_Integration(t *testing.T) {
    // 使用真实工具
    service := NewFileProcessorService(realConfig)

    // 测试完整流程
    result, err := service.GeneratePreview("test.mp4", "mp4", options)
    assert.NoError(t, err)
    assert.FileExists(t, result.ThumbnailPath)
}
```

### 3. 性能测试

```go
func BenchmarkVideoProcessor_ExtractMetadata(b *testing.B) {
    processor := NewVideoProcessor(ffmpeg)

    for i := 0; i < b.N; i++ {
        processor.ExtractMetadata("test.mp4")
    }
}
```

## 监控指标

### 关键指标

1. **任务指标**
   - 任务创建速率
   - 任务完成速率
   - 任务失败率
   - 平均执行时间

2. **资源指标**
   - CPU 使用率
   - 内存使用量
   - 磁盘 I/O
   - 临时文件大小

3. **工具指标**
   - FFmpeg 调用次数
   - FFmpeg 失败次数
   - 平均处理时间

### 监控实现

```go
type Metrics struct {
    TaskCreated   prometheus.Counter
    TaskCompleted prometheus.Counter
    TaskFailed    prometheus.Counter
    TaskDuration  prometheus.Histogram
}

func (m *Metrics) RecordTaskComplete(duration time.Duration) {
    m.TaskCompleted.Inc()
    m.TaskDuration.Observe(duration.Seconds())
}
```
