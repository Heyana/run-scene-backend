# 实现要点

## 1. 文件处理策略

### 1.1 图片处理

**支持格式**：JPG, PNG, WebP

**处理流程**：

```
1. 验证图片格式和尺寸
2. 保存原始文件到 static/assets/{id}/file.{ext}
3. 生成WebP缩略图（512x512）
4. 提取元数据：
   - 尺寸（宽x高）
   - 色彩模式（RGB/RGBA/Grayscale）
```

**代码示例**：

```go
func (p *ImageProcessor) ExtractMetadata(filePath string) (*AssetMetadata, error) {
    img, err := imaging.Open(filePath)
    bounds := img.Bounds()

    return &AssetMetadata{
        Width:  bounds.Dx(),
        Height: bounds.Dy(),
        ColorMode: getColorMode(img),
    }, nil
}
```

---

### 1.2 视频处理

**支持格式**：MP4, WebM

**处理流程**：

```
1. 验证视频格式
2. 保存原始文件到 static/assets/{id}/file.{ext}
3. 使用FFmpeg提取元数据
4. 截取视频帧作为缩略图（第1秒或中间帧）
5. 提取元数据：
   - 时长
   - 分辨率
   - 帧率
   - 编码格式
   - 比特率
```

**FFmpeg命令示例**：

```bash
# 提取元数据
ffprobe -v quiet -print_format json -show_format -show_streams video.mp4

# 生成缩略图
ffmpeg -i video.mp4 -ss 00:00:01 -vframes 1 -vf scale=512:512 thumbnail.webp
```

**代码示例**：

```go
func (p *VideoProcessor) ExtractMetadata(filePath string) (*AssetMetadata, error) {
    cmd := exec.Command("ffprobe", "-v", "quiet", "-print_format", "json",
                        "-show_format", "-show_streams", filePath)
    output, err := cmd.Output()

    var info VideoInfo
    json.Unmarshal(output, &info)

    return &AssetMetadata{
        Duration:  info.Format.Duration,
        Width:     info.Streams[0].Width,
        Height:    info.Streams[0].Height,
        FrameRate: parseFrameRate(info.Streams[0].AvgFrameRate),
        Codec:     info.Streams[0].CodecName,
        Bitrate:   info.Format.BitRate,
    }, nil
}
```

---

## 2. 存储优化

### 2.1 文件命名规范

```
static/assets/{id}/
  ├── file.{ext}           # 原始文件，保持原扩展名
  └── thumbnail.webp       # 统一使用WebP格式
```

**优势**：

- 统一存储目录，简化管理
- 按ID分子目录，避免单目录文件过多
- 统一缩略图格式，减少存储空间
- 通过数据库type字段区分类型

---

### 2.2 去重策略

```go
func (s *UploadService) checkDuplicate(fileHash string) (*Asset, bool, error) {
    var asset Asset
    err := s.db.Where("file_hash = ?", fileHash).First(&asset).Error

    if err == gorm.ErrRecordNotFound {
        return nil, false, nil
    }

    return &asset, true, err
}
```

**说明**：

- 基于MD5哈希检测重复文件
- 重复文件直接返回已存在的资产信息
- 节省存储空间和处理时间

---

### 2.3 缩略图生成

```go
func (p *ImageProcessor) GenerateThumbnail(filePath, outputPath string) error {
    img, err := imaging.Open(filePath)

    // 保持宽高比缩放
    thumb := imaging.Fit(img, 512, 512, imaging.Lanczos)

    // 保存为WebP格式
    return imaging.Save(thumb, outputPath, imaging.JPEGQuality(85))
}
```

**配置建议**：

- 尺寸：512x512（可配置）
- 格式：WebP（压缩率高）
- 质量：85（平衡质量和大小）

---

## 3. 并发处理

### 3.1 上传队列

```go
type UploadPool struct {
    workers   int
    taskQueue chan *UploadTask
    wg        sync.WaitGroup
}

func (p *UploadPool) Start() {
    for i := 0; i < p.workers; i++ {
        p.wg.Add(1)
        go p.worker()
    }
}

func (p *UploadPool) worker() {
    defer p.wg.Done()

    for task := range p.taskQueue {
        result := p.processTask(task)
        task.Result <- result
    }
}
```

**配置建议**：

- Worker数量：CPU核心数 \* 2
- 队列大小：100-1000（根据内存调整）

---

### 3.2 批量上传优化

```go
func (s *UploadService) BatchUpload(files []*multipart.FileHeader, metadata UploadMetadata) ([]*UploadResult, error) {
    pool := NewUploadPool(runtime.NumCPU() * 2)
    pool.Start()

    results := make([]*UploadResult, len(files))

    for i, file := range files {
        task := &UploadTask{
            File:     file,
            Metadata: metadata,
            Result:   make(chan *UploadResult, 1),
        }

        pool.Submit(task)
        results[i] = <-task.Result
    }

    pool.Wait()
    return results, nil
}
```

---

## 4. 错误处理

### 4.1 文件验证

```go
func (s *UploadService) validateFile(file *multipart.FileHeader, assetType string) error {
    // 检查文件大小
    maxSize := s.config.MaxFileSize[assetType]
    if file.Size > maxSize {
        return ErrFileTooLarge
    }

    // 检查文件格式
    ext := strings.ToLower(filepath.Ext(file.Filename))
    allowedFormats := s.config.AllowedFormats[assetType]

    if !contains(allowedFormats, ext) {
        return ErrInvalidFormat
    }

    return nil
}
```

---

### 4.2 处理失败回滚

```go
func (s *UploadService) Upload(file *multipart.FileHeader, metadata UploadMetadata) (*Asset, error) {
    // 创建资产记录
    asset := &Asset{...}
    if err := s.db.Create(asset).Error; err != nil {
        return nil, err
    }

    // 保存文件
    filePath, err := s.saveFile(file, metadata.Type, asset.ID)
    if err != nil {
        s.db.Delete(asset) // 回滚数据库记录
        return nil, err
    }

    // 生成缩略图
    processor := s.getProcessor(metadata.Type)
    thumbnailPath := getThumbnailPath(metadata.Type, asset.ID)

    if err := processor.GenerateThumbnail(filePath, thumbnailPath); err != nil {
        os.Remove(filePath) // 删除已保存的文件
        s.db.Delete(asset)  // 回滚数据库记录
        return nil, err
    }

    // 更新资产路径
    asset.FilePath = filePath
    asset.ThumbnailPath = thumbnailPath
    s.db.Save(asset)

    return asset, nil
}
```

---

## 5. 性能优化

### 5.1 数据库查询优化

```go
// 预加载关联数据
func (q *QueryService) GetDetail(id uint) (*Asset, *AssetMetadata, []*Tag, error) {
    var asset Asset
    err := q.db.Preload("Metadata").Preload("Tags").First(&asset, id).Error

    return &asset, asset.Metadata, asset.Tags, err
}

// 使用索引
func (q *QueryService) List(page, pageSize int, filters QueryFilters) ([]*Asset, int64, error) {
    query := q.db.Model(&Asset{})

    // 利用索引字段
    if filters.Type != "" {
        query = query.Where("type = ?", filters.Type)
    }

    if filters.Category != "" {
        query = query.Where("category = ?", filters.Category)
    }

    // 排序使用索引
    query = query.Order("use_count DESC")

    var total int64
    query.Count(&total)

    var assets []*Asset
    err := query.Offset((page - 1) * pageSize).Limit(pageSize).Find(&assets).Error

    return assets, total, err
}
```

---

### 5.2 缓存策略

```go
type CacheService struct {
    cache *cache.Cache
}

// 缓存热门资产
func (c *CacheService) GetPopularAssets(assetType string, limit int) ([]*Asset, error) {
    key := fmt.Sprintf("popular:%s:%d", assetType, limit)

    if cached, found := c.cache.Get(key); found {
        return cached.([]*Asset), nil
    }

    assets, err := c.queryService.GetPopular(assetType, limit)
    if err != nil {
        return nil, err
    }

    c.cache.Set(key, assets, 5*time.Minute)
    return assets, nil
}
```

---

## 6. 安全考虑

### 6.1 文件类型验证

```go
func validateFileType(file *multipart.FileHeader) error {
    // 不仅检查扩展名，还要检查文件头
    f, err := file.Open()
    defer f.Close()

    buffer := make([]byte, 512)
    f.Read(buffer)

    contentType := http.DetectContentType(buffer)

    // 验证MIME类型
    if !isAllowedMimeType(contentType) {
        return ErrInvalidFormat
    }

    return nil
}
```

---

### 6.2 路径安全

```go
func sanitizeFilename(filename string) string {
    // 移除路径分隔符
    filename = filepath.Base(filename)

    // 移除特殊字符
    reg := regexp.MustCompile(`[^a-zA-Z0-9._-]`)
    filename = reg.ReplaceAllString(filename, "_")

    return filename
}
```

---

## 7. 监控和日志

### 7.1 上传日志

```go
func (s *UploadService) logUpload(asset *Asset, metadata UploadMetadata) {
    log.Info("Asset uploaded",
        "asset_id", asset.ID,
        "type", asset.Type,
        "size", asset.FileSize,
        "uploaded_by", metadata.UploadedBy,
        "ip", metadata.UploadIP,
    )
}
```

---

### 7.2 统计更新

```go
func (s *UploadService) updateMetrics(asset *Asset) error {
    today := time.Now().Format("2006-01-02")

    var metrics AssetMetrics
    err := s.db.Where("date = ? AND type = ?", today, asset.Type).
        FirstOrCreate(&metrics).Error

    if err != nil {
        return err
    }

    metrics.UploadCount++
    metrics.UploadSize += asset.FileSize
    metrics.TotalAssets++
    metrics.TotalSize += asset.FileSize

    return s.db.Save(&metrics).Error
}
```
