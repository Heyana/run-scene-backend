# 需求管理平台 - 与现有系统集成

## 集成方案

需求管理平台复用现有的用户权限系统，不需要独立的用户管理。

## 用户系统集成

### 1. 复用现有用户表

```
users (现有表)
  ├─ id
  ├─ username
  ├─ email
  ├─ real_name
  ├─ avatar
  └─ status
```

需求管理平台直接使用 `users` 表，不创建新的用户表。

### 2. 公司创建与成员管理流程

**创建公司：**

```
用户A 创建公司 → 自动成为公司管理员 (company_admin)
```

**邀请成员：**

```
公司管理员 → 选择系统中的用户 → 添加为公司成员 → 分配角色
```

角色说明：

- `company_admin`: 公司管理员，可管理公司、创建项目、邀请成员
- `member`: 普通成员，可参与项目
- `viewer`: 观察者，只读权限

### 3. 公司成员关联

```go
// models/company_member.go
type CompanyMember struct {
    ID        uint
    CompanyID uint
    UserID    uint      // 关联到现有 users 表
    Role      string    // company_admin/member/viewer
    JoinedAt  time.Time

    User      User      // 关联现有 User 模型
    Company   Company
}
```

### 4. 项目成员关联

```go
// models/project_member.go
type ProjectMember struct {
    ID        uint
    ProjectID uint
    UserID    uint      // 关联到现有 users 表
    Role      string    // project_admin/developer/viewer
    JoinedAt  time.Time

    User      User      // 关联现有 User 模型
    Project   Project
}
```

### 5. 任务负责人关联

```go
// models/mission.go
type Mission struct {
    // ... 其他字段
    AssigneeID  *uint     // 关联到现有 users 表
    ReporterID  uint      // 关联到现有 users 表

    Assignee    *User     // 关联现有 User 模型
    Reporter    User      // 关联现有 User 模型
}
```

## 权限系统集成

### 1. 复用现有权限框架

使用现有的权限中间件和权限计算服务：

```go
// 复用现有中间件
import "go_wails_project_manager/middleware"

// 路由注册
requirementGroup := api.Group("/api/requirement")
requirementGroup.Use(middleware.AuthMiddleware())
{
    // 公司管理需要特定权限
    companies := requirementGroup.Group("/companies")
    companies.Use(middleware.RequirePermission("requirement", "admin"))

    // 项目管理
    projects := requirementGroup.Group("/projects")
    projects.Use(middleware.RequirePermission("requirement", "create"))
}
```

### 2. 新增需求管理权限

在 `database/init_auth.go` 中添加需求管理相关权限：

```go
// 需求管理权限
permissions := []models.Permission{
    // 公司管理
    {Code: "requirement:company:read", Name: "查看公司", Resource: "requirement_company", Action: "read"},
    {Code: "requirement:company:create", Name: "创建公司", Resource: "requirement_company", Action: "create"},
    {Code: "requirement:company:update", Name: "更新公司", Resource: "requirement_company", Action: "update"},
    {Code: "requirement:company:delete", Name: "删除公司", Resource: "requirement_company", Action: "delete"},

    // 项目管理
    {Code: "requirement:project:read", Name: "查看项目", Resource: "requirement_project", Action: "read"},
    {Code: "requirement:project:create", Name: "创建项目", Resource: "requirement_project", Action: "create"},
    {Code: "requirement:project:update", Name: "更新项目", Resource: "requirement_project", Action: "update"},
    {Code: "requirement:project:delete", Name: "删除项目", Resource: "requirement_project", Action: "delete"},

    // 任务管理
    {Code: "requirement:mission:read", Name: "查看任务", Resource: "requirement_mission", Action: "read"},
    {Code: "requirement:mission:create", Name: "创建任务", Resource: "requirement_mission", Action: "create"},
    {Code: "requirement:mission:update", Name: "更新任务", Resource: "requirement_mission", Action: "update"},
    {Code: "requirement:mission:delete", Name: "删除任务", Resource: "requirement_mission", Action: "delete"},
}
```

### 3. 权限组配置

```go
// 需求管理权限组
groups := []struct {
    Group       models.PermissionGroup
    Permissions []string
}{
    {
        Group: models.PermissionGroup{
            Code:        "requirement_admin",
            Name:        "需求管理管理员",
            Description: "需求管理平台的完整管理权限",
            IsSystem:    true,
        },
        Permissions: []string{
            "requirement:company:read", "requirement:company:create",
            "requirement:company:update", "requirement:company:delete",
            "requirement:project:read", "requirement:project:create",
            "requirement:project:update", "requirement:project:delete",
            "requirement:mission:read", "requirement:mission:create",
            "requirement:mission:update", "requirement:mission:delete",
        },
    },
    {
        Group: models.PermissionGroup{
            Code:        "requirement_member",
            Name:        "需求管理成员",
            Description: "可以创建和管理自己的任务",
            IsSystem:    true,
        },
        Permissions: []string{
            "requirement:project:read",
            "requirement:mission:read", "requirement:mission:create",
            "requirement:mission:update",
        },
    },
}
```

## 权限检查逻辑

### 1. 公司级别权限

```go
// middleware/requirement_permission.go
func RequireCompanyAccess(companyID uint) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetUint("user_id")

        // 检查是否是公司成员
        var member CompanyMember
        if err := db.Where("company_id = ? AND user_id = ?", companyID, userID).
            First(&member).Error; err != nil {
            response.Forbidden(c, "无权访问该公司")
            c.Abort()
            return
        }

        c.Set("company_role", member.Role)
        c.Next()
    }
}
```

### 2. 项目级别权限

```go
func RequireProjectAccess(projectID uint) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetUint("user_id")

        // 检查是否是项目成员
        var member ProjectMember
        if err := db.Where("project_id = ? AND user_id = ?", projectID, userID).
            First(&member).Error; err != nil {
            response.Forbidden(c, "无权访问该项目")
            c.Abort()
            return
        }

        c.Set("project_role", member.Role)
        c.Next()
    }
}
```

### 3. 任务级别权限

```go
func CanEditMission(c *gin.Context, mission *Mission) bool {
    userID := c.GetUint("user_id")
    projectRole := c.GetString("project_role")

    // 项目管理员可以编辑所有任务
    if projectRole == "project_admin" {
        return true
    }

    // 任务负责人可以编辑
    if mission.AssigneeID != nil && *mission.AssigneeID == userID {
        return true
    }

    // 任务创建人可以编辑
    if mission.ReporterID == userID {
        return true
    }

    return false
}
```

## 前端集成

### 1. 复用现有认证

```typescript
// 复用现有的 auth.ts
import { getToken, getUserInfo } from "@/utils/auth";

// 获取当前用户信息
const currentUser = getUserInfo();

// API请求自动带上token（已有的http拦截器）
```

### 2. 用户选择器组件

```typescript
// components/UserSelector.tsx
import { api } from '@/api/api'

const UserSelector = defineComponent({
  setup() {
    const users = ref<User[]>([])

    // 加载用户列表（复用现有API）
    const loadUsers = async () => {
      const res = await api.user.getUserList({
        page: 1,
        page_size: 100
      })
      users.value = res.data.items
    }

    return () => (
      <Select>
        {users.value.map(user => (
          <Select.Option value={user.id}>
            <Avatar src={user.avatar} />
            {user.real_name || user.username}
          </Select.Option>
        ))}
      </Select>
    )
  }
})
```

### 3. 权限判断

```typescript
// stores/requirementStore.ts
import { useUserStore } from "@/stores/userStore";

export const useRequirementStore = defineStore("requirement", {
  getters: {
    // 是否有公司管理权限
    canManageCompany(): boolean {
      const userStore = useUserStore();
      return userStore.hasPermission("requirement:company:admin");
    },

    // 是否可以编辑任务
    canEditMission: (state) => (mission: Mission) => {
      const userStore = useUserStore();
      const currentUserId = userStore.currentUser?.id;

      // 项目管理员
      if (state.currentProjectRole === "project_admin") {
        return true;
      }

      // 任务负责人或创建人
      return (
        mission.assignee_id === currentUserId ||
        mission.reporter_id === currentUserId
      );
    },
  },
});
```

## 数据隔离

### 1. 公司数据隔离

```go
// 用户只能看到自己所在公司的数据
func (cs *CompanyService) ListUserCompanies(userID uint) ([]Company, error) {
    var companies []Company
    err := cs.db.Joins("JOIN company_members ON companies.id = company_members.company_id").
        Where("company_members.user_id = ?", userID).
        Find(&companies).Error
    return companies, err
}
```

### 2. 项目数据隔离

```go
// 用户只能看到自己有权限的项目
func (ps *ProjectService) ListUserProjects(userID uint) ([]Project, error) {
    var projects []Project
    err := ps.db.Joins("JOIN project_members ON projects.id = project_members.project_id").
        Where("project_members.user_id = ?", userID).
        Find(&projects).Error
    return projects, err
}
```

### 3. 任务数据隔离

```go
// 用户只能看到所在项目的任务
func (ms *MissionService) ListMissions(projectID uint, userID uint) ([]Mission, error) {
    // 先检查用户是否是项目成员
    var member ProjectMember
    if err := ms.db.Where("project_id = ? AND user_id = ?", projectID, userID).
        First(&member).Error; err != nil {
        return nil, errors.New("无权访问该项目")
    }

    var missions []Mission
    err := ms.db.Where("project_id = ?", projectID).Find(&missions).Error
    return missions, err
}
```

## 路由集成

```go
// api/routes.go
func SetupRequirementRoutes(router *gin.Engine) {
    requirementGroup := router.Group("/api/requirement")
    requirementGroup.Use(middleware.AuthMiddleware()) // 复用现有认证中间件

    // 公司管理
    companies := requirementGroup.Group("/companies")
    {
        companies.GET("", companyController.ListUserCompanies)
        companies.POST("", middleware.RequirePermission("requirement_company", "create"),
            companyController.Create)
        companies.GET("/:id", companyController.GetDetail)
        companies.PUT("/:id", companyController.Update)
    }

    // 项目管理
    projects := requirementGroup.Group("/projects")
    {
        projects.GET("", projectController.ListUserProjects)
        projects.POST("", middleware.RequirePermission("requirement_project", "create"),
            projectController.Create)
        projects.GET("/:id", projectController.GetDetail)
    }

    // 任务管理
    missions := requirementGroup.Group("/missions")
    {
        missions.GET("", missionController.List)
        missions.POST("", missionController.Create)
        missions.GET("/:id", missionController.GetDetail)
        missions.PUT("/:id", missionController.Update)
    }
}
```

## 总结

集成要点：

1. ✅ 复用现有 `users` 表，不创建新用户系统
2. ✅ 复用现有权限框架（middleware、permission_calculator）
3. ✅ 新增需求管理相关权限到现有权限表
4. ✅ 公司/项目成员表关联到现有用户
5. ✅ 前端复用现有认证和用户API
6. ✅ 数据隔离确保用户只能访问有权限的数据
7. ✅ 权限检查分为：系统权限 + 公司角色 + 项目角色

## 典型使用场景

### 场景1：创建公司并邀请成员

```
1. 用户张三登录系统
2. 创建公司"XX科技"
3. 系统自动将张三设为公司管理员
4. 张三邀请李四、王五加入公司
   - 李四：company_admin（共同管理）
   - 王五：member（普通成员）
5. 张三创建项目"产品开发"
6. 添加项目成员：
   - 李四：project_admin
   - 王五：developer
```

### 场景2：跨公司协作

```
用户可以同时属于多个公司：
- 张三在"A公司"是管理员
- 张三在"B公司"是普通成员
- 切换公司时，权限自动切换
```

### 场景3：外部用户协作

```
1. 公司管理员邀请外部用户（系统中已存在的用户）
2. 外部用户接受邀请后成为公司成员
3. 可以参与该公司的项目
4. 离开公司后，自动失去访问权限
```

## 成员管理API

### 添加公司成员

```go
// controllers/company_controller.go
func (cc *CompanyController) AddMember(c *gin.Context) {
    companyID := c.Param("id")

    var req struct {
        UserID uint   `json:"user_id" binding:"required"`
        Role   string `json:"role" binding:"required,oneof=company_admin member viewer"`
    }

    // 检查当前用户是否是公司管理员
    currentUserID := c.GetUint("user_id")
    if !cc.service.IsCompanyAdmin(companyID, currentUserID) {
        response.Forbidden(c, "只有公司管理员可以添加成员")
        return
    }

    // 检查被添加的用户是否存在
    var user User
    if err := db.First(&user, req.UserID).Error; err != nil {
        response.NotFound(c, "用户不存在")
        return
    }

    // 添加成员
    member := CompanyMember{
        CompanyID: companyID,
        UserID:    req.UserID,
        Role:      req.Role,
        JoinedAt:  time.Now(),
    }

    if err := db.Create(&member).Error; err != nil {
        response.InternalServerError(c, "添加成员失败")
        return
    }

    response.Success(c, member)
}
```

### 前端成员选择器

```typescript
// components/CompanyMemberSelector.tsx
const CompanyMemberSelector = defineComponent({
  props: {
    companyId: Number,
    excludeUserIds: Array as PropType<number[]>
  },
  setup(props) {
    const allUsers = ref<User[]>([])
    const companyMembers = ref<number[]>([])

    // 加载所有系统用户
    const loadAllUsers = async () => {
      const res = await api.user.getUserList({
        page: 1,
        page_size: 1000
      })
      allUsers.value = res.data.items
    }

    // 加载公司现有成员
    const loadCompanyMembers = async () => {
      const res = await api.company.getMembers(props.companyId)
      companyMembers.value = res.data.map(m => m.user_id)
    }

    // 可选用户（排除已是成员的用户）
    const availableUsers = computed(() => {
      return allUsers.value.filter(user =>
        !companyMembers.value.includes(user.id) &&
        !props.excludeUserIds?.includes(user.id)
      )
    })

    return () => (
      <Select
        placeholder="选择用户"
        showSearch
        filterOption={(input, option) => {
          const user = allUsers.value.find(u => u.id === option.value)
          return user?.real_name?.includes(input) ||
                 user?.username?.includes(input)
        }}
      >
        {availableUsers.value.map(user => (
          <Select.Option value={user.id}>
            <Space>
              <Avatar src={user.avatar} size="small" />
              <span>{user.real_name || user.username}</span>
              <span style={{ color: '#999' }}>({user.email})</span>
            </Space>
          </Select.Option>
        ))}
      </Select>
    )
  }
})
```

## 权限判断示例

### 后端权限检查

```go
// 创建公司时自动设为管理员
func (cs *CompanyService) CreateCompany(userID uint, req CreateCompanyRequest) (*Company, error) {
    company := Company{
        Name:        req.Name,
        Description: req.Description,
        OwnerID:     userID,
        Status:      "active",
    }

    if err := cs.db.Create(&company).Error; err != nil {
        return nil, err
    }

    // 自动添加创建人为公司管理员
    member := CompanyMember{
        CompanyID: company.ID,
        UserID:    userID,
        Role:      "company_admin",
        JoinedAt:  time.Now(),
    }
    cs.db.Create(&member)

    return &company, nil
}

// 检查是否是公司管理员
func (cs *CompanyService) IsCompanyAdmin(companyID uint, userID uint) bool {
    var count int64
    cs.db.Model(&CompanyMember{}).
        Where("company_id = ? AND user_id = ? AND role = ?",
            companyID, userID, "company_admin").
        Count(&count)
    return count > 0
}
```

### 前端权限显示

```typescript
// views/CompanyDetail.tsx
const CompanyDetail = defineComponent({
  setup() {
    const company = ref<Company | null>(null)
    const currentUserRole = ref<string>('')

    const isAdmin = computed(() => {
      return currentUserRole.value === 'company_admin'
    })

    return () => (
      <div>
        <h1>{company.value?.name}</h1>

        {/* 只有管理员可以看到邀请按钮 */}
        {isAdmin.value && (
          <Button onClick={handleInviteMember}>
            邀请成员
          </Button>
        )}

        {/* 成员列表 */}
        <MemberList
          members={company.value?.members}
          canManage={isAdmin.value}
        />
      </div>
    )
  }
})
```
