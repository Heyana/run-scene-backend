# 路由守卫和认证实现

## 实现时间

2026-02-14

## 实现方案

采用 Vue Router 路由守卫 + meta 配置的最佳实践方案，统一管理认证逻辑。

## 核心文件

### 1. 认证工具 (`utils/auth.ts`)

提供认证相关的工具函数和事件系统：

```typescript
// 功能：
-triggerAuthRequired() -
  触发需要认证事件 -
  onAuthRequired(listener) -
  监听需要认证事件 -
  isAuthenticated() -
  检查是否已登录 -
  getCurrentUser() -
  获取当前用户信息 -
  logout() -
  登出;
```

### 2. 认证弹窗组件 (`components/AuthModal.tsx`)

通用的登录/注册弹窗组件：

**特性：**

- 支持登录和注册两个标签页
- 表单验证（用户名、密码、邮箱等）
- 登录成功后自动保存 token 和用户信息
- 支持回调函数（onSuccess, onCancel）

**使用方式：**

```tsx
<AuthModal
  visible={authModalVisible.value}
  onUpdate:visible={(val) => (authModalVisible.value = val)}
  onSuccess={handleAuthSuccess}
  defaultTab="login"
/>
```

### 3. 路由配置 (`router/index.ts`)

**路由 meta 配置：**

```typescript
{
  path: "/user-management",
  meta: { requiresAuth: true },  // 需要认证
  children: [...]
}
```

**全局路由守卫：**

```typescript
router.beforeEach((to, _from, next) => {
  if (to.meta.requiresAuth) {
    if (!isAuthenticated()) {
      // 未登录，添加 needAuth 参数触发弹窗
      next({ ...to, query: { ...to.query, needAuth: "1" } });
      return;
    }
  }
  next();
});
```

### 4. HTTP 拦截器 (`api/http.ts`)

**401 错误处理：**

```typescript
if (msg === codeMap[401]) {
  localStorage.removeItem(constant.clientToken);
  // 触发全局认证事件
  triggerAuthRequired();
  return Promise.reject(new Error("未授权访问"));
}
```

### 5. 布局组件 (`views/UserManagement/index.tsx`)

在父级布局中统一处理认证弹窗：

```typescript
// 监听路由 query 参数
watch(
  () => route.query.needAuth,
  (needAuth) => {
    if (needAuth === "1") {
      authModalVisible.value = true;
    }
  },
  { immediate: true },
);

// 监听全局认证事件（401错误）
onMounted(() => {
  unsubscribe = onAuthRequired(() => {
    authModalVisible.value = true;
  });
});
```

## 认证流程

### 场景1：用户直接访问需要认证的页面

1. 用户访问 `/user-management/users`
2. 路由守卫检测到 `meta.requiresAuth = true`
3. 检查 `isAuthenticated()` 返回 false
4. 重定向到 `/user-management/users?needAuth=1`
5. 布局组件监听到 `needAuth=1`，显示登录弹窗
6. 用户登录成功后，移除 `needAuth` 参数，继续访问

### 场景2：用户已登录，但 token 过期

1. 用户在页面中操作，调用 API
2. 后端返回 401 错误
3. HTTP 拦截器捕获 401，调用 `triggerAuthRequired()`
4. 布局组件监听到认证事件，显示登录弹窗
5. 用户重新登录后，可以继续操作

## 优势

### 1. 集中管理

- 所有认证逻辑在路由守卫中统一处理
- 不需要在每个页面重复编写认证代码

### 2. 声明式配置

- 通过 `meta.requiresAuth` 声明式配置
- 清晰明了，易于维护

### 3. 全局事件系统

- 支持多种触发方式（路由守卫、HTTP 拦截器）
- 解耦组件和认证逻辑

### 4. 用户体验好

- 弹窗式登录，不跳转页面
- 登录成功后自动继续之前的操作
- 支持 401 错误自动弹出登录框

## 配置说明

### 为路由添加认证

只需在路由配置中添加 `meta.requiresAuth`:

```typescript
{
  path: "/protected-page",
  component: () => import("@/views/ProtectedPage"),
  meta: { requiresAuth: true }  // 添加这一行
}
```

### Token 存储

- Token 存储在 `localStorage` 中，key 为 `token`
- 用户信息存储在 `localStorage` 中，key 为 `user`

### HTTP 请求自动携带 Token

在 `http.ts` 的请求拦截器中：

```typescript
http.interceptors.request.use((config) => {
  config.headers.Authorization = "Bearer " + localStorage.getItem("token");
  return config;
});
```

## 文件清单

### 新增文件

- `frontend/src/utils/auth.ts` - 认证工具函数
- `frontend/src/components/AuthModal.tsx` - 认证弹窗组件

### 修改文件

- `frontend/src/router/index.ts` - 添加路由守卫和 meta 配置
- `frontend/src/api/http.ts` - 添加 401 错误处理
- `frontend/src/views/UserManagement/index.tsx` - 添加认证弹窗监听

### 删除文件

- `frontend/src/hooks/useAuth.ts` - 不再需要（改用路由守卫）

## 测试建议

1. 未登录访问受保护页面 - 应弹出登录框
2. 登录成功后访问受保护页面 - 应正常访问
3. Token 过期后调用 API - 应弹出登录框
4. 登录后刷新页面 - 应保持登录状态
5. 登出后访问受保护页面 - 应弹出登录框

## 后续优化

1. 添加 Token 刷新机制
2. 添加记住密码功能
3. 添加第三方登录（OAuth）
4. 添加验证码功能
5. 添加登录日志记录
