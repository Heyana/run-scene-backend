# 高级特性

## 概述

本文档介绍文件处理器系统的高级特性，包括通知系统、工作流管理、任务依赖、分布式处理等。

## 通知系统

### 通知接口

```go
// services/task/task_notifier.go

package task

import (
    "bytes"
    "encoding/json"
    "fmt"
    "go_wails_project_manager/models"
    "net/http"
    "net/smtp"
)

type TaskNotifier struct {
    emailConfig   *EmailConfig
    webhookClient *http.Client
}

type EmailConfig struct {
    SMTPHost     string
    SMTPPort     int
    Username     string
    Password     string
    FromAddress  string
}

func NewTaskNotifier(emailConfig *EmailConfig) *TaskNotifier {
    return &TaskNotifier{
        emailConfig:   emailConfig,
        webhookClient: &http.Client{Timeout: 10 * time.Second},
    }
}
```

### 邮件通知

```go
// SendEmail 发送邮件通知
func (n *TaskNotifier) SendEmail(to, subject, body string) error {
    if n.emailConfig == nil {
        return fmt.Errorf("邮件配置未设置")
    }

    // 构建邮件
    msg := []byte(fmt.Sprintf(
        "From: %s\r\n"+
            "To: %s\r\n"+
            "Subject: %s\r\n"+
            "\r\n"+
            "%s\r\n",
        n.emailConfig.FromAddress,
        to,
        subject,
        body,
    ))

    // 发送邮件
    auth := smtp.PlainAuth(
        "",
        n.emailConfig.Username,
        n.emailConfig.Password,
        n.emailConfig.SMTPHost,
    )

    addr := fmt.Sprintf("%s:%d", n.emailConfig.SMTPHost, n.emailConfig.SMTPPort)

    return smtp.SendMail(addr, auth, n.emailConfig.FromAddress, []string{to}, msg)
}

// NotifyTaskComplete 通知任务完成
func (n *TaskNotifier) NotifyTaskComplete(task *models.Task) error {
    if task.NotifyEmail == "" {
        return nil
    }

    subject := fmt.Sprintf("任务完成通知 - %s", task.Type)
    body := fmt.Sprintf(
        "您的任务已完成\n\n"+
            "任务ID: %d\n"+
            "任务类型: %s\n"+
            "状态: %s\n"+
            "耗时: %d秒\n"+
            "输出文件: %s\n",
        task.ID,
        task.Type,
        task.Status,
        task.Duration,
        task.OutputFile,
    )

    return n.SendEmail(task.NotifyEmail, subject, body)
}

// NotifyTaskFailed 通知任务失败
func (n *TaskNotifier) NotifyTaskFailed(task *models.Task) error {
    if task.NotifyEmail == "" {
        return nil
    }

    subject := fmt.Sprintf("任务失败通知 - %s", task.Type)
    body := fmt.Sprintf(
        "您的任务执行失败\n\n"+
            "任务ID: %d\n"+
            "任务类型: %s\n"+
            "错误信息: %s\n"+
            "重试次数: %d/%d\n",
        task.ID,
        task.Type,
        task.Error,
        task.RetryCount,
        task.MaxRetries,
    )

    return n.SendEmail(task.NotifyEmail, subject, body)
}
```

### Webhook 通知

```go
// SendWebhook 发送 Webhook 通知
func (n *TaskNotifier) SendWebhook(url string, data interface{}) error {
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }

    resp, err := n.webhookClient.Post(url, "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode >= 400 {
        return fmt.Errorf("webhook 返回错误状态码: %d", resp.StatusCode)
    }

    return nil
}

// NotifyWebhook 通知 Webhook
func (n *TaskNotifier) NotifyWebhook(task *models.Task) error {
    if task.NotifyWebhook == "" {
        return nil
    }

    data := map[string]interface{}{
        "task_id":     task.ID,
        "type":        task.Type,
        "status":      task.Status,
        "progress":    task.Progress,
        "input_file":  task.InputFile,
        "output_file": task.OutputFile,
        "error":       task.Error,
        "duration":    task.Duration,
        "created_at":  task.CreatedAt,
        "completed_at": task.CompletedAt,
    }

    return n.SendWebhook(task.NotifyWebhook, data)
}
```

### 回调通知

```go
// SendCallback 发送回调请求
func (n *TaskNotifier) SendCallback(task *models.Task) error {
    if task.CallbackURL == "" {
        return nil
    }

    data := map[string]interface{}{
        "task_id":     task.ID,
        "status":      task.Status,
        "output_file": task.OutputFile,
        "error":       task.Error,
    }

    return n.SendWebhook(task.CallbackURL, data)
}
```

## 工作流管理

### 工作流模型

```go
// models/workflow.go

type Workflow struct {
    ID          uint           `gorm:"primarykey" json:"id"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

    Name        string         `json:"name"`
    Description string         `json:"description"`
    Status      string         `json:"status"` // pending, running, completed, failed

    // 工作流定义（JSON）
    Definition  string         `json:"definition"`

    // 执行信息
    StartedAt   *time.Time     `json:"started_at"`
    CompletedAt *time.Time     `json:"completed_at"`
    Duration    int64          `json:"duration"`

    // 关联
    UserID      uint           `json:"user_id"`
}

// WorkflowStep 工作流步骤
type WorkflowStep struct {
    ID          uint           `gorm:"primarykey" json:"id"`
    WorkflowID  uint           `json:"workflow_id"`

    Name        string         `json:"name"`
    Type        string         `json:"type"`        // task, condition, parallel
    Order       int            `json:"order"`

    // 任务配置（JSON）
    Config      string         `json:"config"`

    // 依赖
    DependsOn   string         `json:"depends_on"`  // JSON数组

    // 状态
    Status      string         `json:"status"`
    TaskID      *uint          `json:"task_id"`     // 关联的任务ID

    // 执行信息
    StartedAt   *time.Time     `json:"started_at"`
    CompletedAt *time.Time     `json:"completed_at"`
}
```

### 工作流服务

```go
// services/workflow/workflow_service.go

package workflow

import (
    "encoding/json"
    "fmt"
    "go_wails_project_manager/models"
    "go_wails_project_manager/services/task"
    "gorm.io/gorm"
)

type WorkflowService struct {
    db          *gorm.DB
    taskService *task.TaskService
}

func NewWorkflowService(db *gorm.DB, taskService *task.TaskService) *WorkflowService {
    return &WorkflowService{
        db:          db,
        taskService: taskService,
    }
}

// CreateWorkflow 创建工作流
func (s *WorkflowService) CreateWorkflow(workflow *models.Workflow) error {
    return s.db.Create(workflow).Error
}

// StartWorkflow 启动工作流
func (s *WorkflowService) StartWorkflow(workflowID uint) error {
    var workflow models.Workflow
    if err := s.db.First(&workflow, workflowID).Error; err != nil {
        return err
    }

    // 更新状态
    now := time.Now()
    workflow.Status = "running"
    workflow.StartedAt = &now
    s.db.Save(&workflow)

    // 获取工作流步骤
    var steps []models.WorkflowStep
    s.db.Where("workflow_id = ?", workflowID).Order("order").Find(&steps)

    // 执行工作流
    go s.executeWorkflow(&workflow, steps)

    return nil
}

// executeWorkflow 执行工作流
func (s *WorkflowService) executeWorkflow(workflow *models.Workflow, steps []models.WorkflowStep) {
    // 构建依赖图
    stepMap := make(map[uint]*models.WorkflowStep)
    for i := range steps {
        stepMap[steps[i].ID] = &steps[i]
    }

    // 执行步骤
    for _, step := range steps {
        // 检查依赖
        if !s.checkDependencies(&step, stepMap) {
            continue
        }

        // 执行步骤
        if err := s.executeStep(&step); err != nil {
            workflow.Status = "failed"
            s.db.Save(workflow)
            return
        }
    }

    // 完成工作流
    now := time.Now()
    workflow.Status = "completed"
    workflow.CompletedAt = &now
    if workflow.StartedAt != nil {
        workflow.Duration = int64(now.Sub(*workflow.StartedAt).Seconds())
    }
    s.db.Save(workflow)
}

// checkDependencies 检查依赖是否满足
func (s *WorkflowService) checkDependencies(step *models.WorkflowStep, stepMap map[uint]*models.WorkflowStep) bool {
    if step.DependsOn == "" {
        return true
    }

    var depends []uint
    json.Unmarshal([]byte(step.DependsOn), &depends)

    for _, depID := range depends {
        depStep, exists := stepMap[depID]
        if !exists || depStep.Status != "completed" {
            return false
        }
    }

    return true
}

// executeStep 执行步骤
func (s *WorkflowService) executeStep(step *models.WorkflowStep) error {
    // 更新状态
    now := time.Now()
    step.Status = "running"
    step.StartedAt = &now
    s.db.Save(step)

    // 解析配置
    var config map[string]interface{}
    json.Unmarshal([]byte(step.Config), &config)

    // 创建任务
    task := &models.Task{
        Type:       config["type"].(string),
        InputFile:  config["input_file"].(string),
        OutputFile: config["output_file"].(string),
    }

    if err := s.taskService.CreateTask(task); err != nil {
        step.Status = "failed"
        s.db.Save(step)
        return err
    }

    step.TaskID = &task.ID
    s.db.Save(step)

    // 等待任务完成
    for {
        var t models.Task
        s.db.First(&t, task.ID)

        if t.Status == "completed" {
            step.Status = "completed"
            now := time.Now()
            step.CompletedAt = &now
            s.db.Save(step)
            return nil
        } else if t.Status == "failed" {
            step.Status = "failed"
            s.db.Save(step)
            return fmt.Errorf("任务失败")
        }

        time.Sleep(1 * time.Second)
    }
}
```

### 工作流示例

```go
// 创建视频处理工作流
workflow := &models.Workflow{
    Name:        "视频处理流程",
    Description: "转码 -> 生成缩略图 -> 生成预览图",
    Status:      "pending",
    UserID:      123,
}

// 定义步骤
steps := []models.WorkflowStep{
    {
        Name:   "视频转码",
        Type:   "task",
        Order:  1,
        Config: `{"type":"video_convert","input_file":"input.mp4","output_file":"output.webm"}`,
    },
    {
        Name:      "生成缩略图",
        Type:      "task",
        Order:     2,
        DependsOn: `[1]`, // 依赖步骤1
        Config:    `{"type":"video_thumbnail","input_file":"output.webm","output_file":"thumb.jpg"}`,
    },
    {
        Name:      "生成预览图",
        Type:      "task",
        Order:     3,
        DependsOn: `[1]`, // 依赖步骤1
        Config:    `{"type":"video_preview","input_file":"output.webm","output_file":"preview.jpg"}`,
    },
}

// 创建工作流
workflowService.CreateWorkflow(workflow)

// 添加步骤
for _, step := range steps {
    step.WorkflowID = workflow.ID
    db.Create(&step)
}

// 启动工作流
workflowService.StartWorkflow(workflow.ID)
```

## 任务依赖管理

### 依赖检查

```go
// CheckDependencies 检查任务依赖
func (s *TaskService) CheckDependencies(task *models.Task) (bool, error) {
    if task.DependsOn == "" {
        return true, nil
    }

    var depends []uint
    if err := json.Unmarshal([]byte(task.DependsOn), &depends); err != nil {
        return false, err
    }

    for _, depID := range depends {
        var depTask models.Task
        if err := s.db.First(&depTask, depID).Error; err != nil {
            return false, err
        }

        if depTask.Status != models.TaskStatusCompleted {
            return false, nil
        }
    }

    return true, nil
}
```

### 依赖触发

```go
// OnTaskComplete 任务完成时触发依赖任务
func (s *TaskService) OnTaskComplete(taskID uint) error {
    // 查找依赖此任务的其他任务
    var dependentTasks []models.Task
    s.db.Where("depends_on LIKE ?", fmt.Sprintf("%%[%d]%%", taskID)).Find(&dependentTasks)

    for _, task := range dependentTasks {
        // 检查所有依赖是否满足
        ready, err := s.CheckDependencies(&task)
        if err != nil {
            continue
        }

        if ready {
            // 启动任务
            s.StartTask(task.ID)
        }
    }

    return nil
}
```

## 分布式任务处理

### 任务分发

```go
// services/task/task_distributor.go

type TaskDistributor struct {
    workers []string // 工作节点地址
    client  *http.Client
}

// DistributeTask 分发任务到工作节点
func (d *TaskDistributor) DistributeTask(task *models.Task) (string, error) {
    // 选择工作节点（负载均衡）
    worker := d.selectWorker()

    // 发送任务到工作节点
    data, _ := json.Marshal(task)
    resp, err := d.client.Post(
        fmt.Sprintf("%s/api/tasks", worker),
        "application/json",
        bytes.NewBuffer(data),
    )

    if err != nil {
        return "", err
    }
    defer resp.Body.Close()

    return worker, nil
}

// selectWorker 选择工作节点
func (d *TaskDistributor) selectWorker() string {
    // 简单轮询
    // TODO: 实现更智能的负载均衡
    return d.workers[rand.Intn(len(d.workers))]
}
```

## 性能监控

### 指标收集

```go
// services/task/task_metrics.go

type TaskMetrics struct {
    TaskCreated   prometheus.Counter
    TaskCompleted prometheus.Counter
    TaskFailed    prometheus.Counter
    TaskDuration  prometheus.Histogram
    QueueSize     prometheus.Gauge
}

func NewTaskMetrics() *TaskMetrics {
    return &TaskMetrics{
        TaskCreated: prometheus.NewCounter(prometheus.CounterOpts{
            Name: "task_created_total",
            Help: "Total number of tasks created",
        }),
        TaskCompleted: prometheus.NewCounter(prometheus.CounterOpts{
            Name: "task_completed_total",
            Help: "Total number of tasks completed",
        }),
        TaskFailed: prometheus.NewCounter(prometheus.CounterOpts{
            Name: "task_failed_total",
            Help: "Total number of tasks failed",
        }),
        TaskDuration: prometheus.NewHistogram(prometheus.HistogramOpts{
            Name:    "task_duration_seconds",
            Help:    "Task execution duration in seconds",
            Buckets: prometheus.ExponentialBuckets(1, 2, 10),
        }),
        QueueSize: prometheus.NewGauge(prometheus.GaugeOpts{
            Name: "task_queue_size",
            Help: "Current size of task queue",
        }),
    }
}

// RecordTaskCreated 记录任务创建
func (m *TaskMetrics) RecordTaskCreated() {
    m.TaskCreated.Inc()
}

// RecordTaskCompleted 记录任务完成
func (m *TaskMetrics) RecordTaskCompleted(duration time.Duration) {
    m.TaskCompleted.Inc()
    m.TaskDuration.Observe(duration.Seconds())
}

// RecordTaskFailed 记录任务失败
func (m *TaskMetrics) RecordTaskFailed() {
    m.TaskFailed.Inc()
}

// UpdateQueueSize 更新队列大小
func (m *TaskMetrics) UpdateQueueSize(size int) {
    m.QueueSize.Set(float64(size))
}
```

## 缓存优化

### 元数据缓存

```go
// services/fileprocessor/metadata_cache.go

type MetadataCache struct {
    cache map[string]*CacheEntry
    ttl   time.Duration
    mu    sync.RWMutex
}

type CacheEntry struct {
    Metadata  *FileMetadata
    ExpiresAt time.Time
}

func NewMetadataCache(ttl time.Duration) *MetadataCache {
    cache := &MetadataCache{
        cache: make(map[string]*CacheEntry),
        ttl:   ttl,
    }

    // 启动清理协程
    go cache.cleanup()

    return cache
}

// Get 获取缓存
func (c *MetadataCache) Get(filePath string) (*FileMetadata, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    entry, exists := c.cache[filePath]
    if !exists {
        return nil, false
    }

    if time.Now().After(entry.ExpiresAt) {
        return nil, false
    }

    return entry.Metadata, true
}

// Set 设置缓存
func (c *MetadataCache) Set(filePath string, metadata *FileMetadata) {
    c.mu.Lock()
    defer c.mu.Unlock()

    c.cache[filePath] = &CacheEntry{
        Metadata:  metadata,
        ExpiresAt: time.Now().Add(c.ttl),
    }
}

// cleanup 清理过期缓存
func (c *MetadataCache) cleanup() {
    ticker := time.NewTicker(time.Minute)
    defer ticker.Stop()

    for range ticker.C {
        c.mu.Lock()
        now := time.Now()
        for key, entry := range c.cache {
            if now.After(entry.ExpiresAt) {
                delete(c.cache, key)
            }
        }
        c.mu.Unlock()
    }
}
```

## 使用示例

### 完整工作流

```go
// 1. 初始化服务
taskService := task.NewTaskService(db)
notifier := task.NewTaskNotifier(emailConfig)
workflowService := workflow.NewWorkflowService(db, taskService)

// 2. 创建工作流
workflow := &models.Workflow{
    Name: "视频处理流程",
}
workflowService.CreateWorkflow(workflow)

// 3. 添加步骤
// ...

// 4. 启动工作流
workflowService.StartWorkflow(workflow.ID)

// 5. 监控进度
// ...

// 6. 接收通知
// 邮件、Webhook、回调
```
