# 实现要点

## 1. 文件上传处理

### 1.1 文件验证

```go
func validateFile(file *multipart.FileHeader, allowedTypes []string) error {
    // 检查文件大小
    if file.Size > maxFileSize {
        return ErrFileTooLarge
    }

    // 检查文件类型
    ext := strings.ToLower(filepath.Ext(file.Filename))
    ext = strings.TrimPrefix(ext, ".")

    allowed := false
    for _, t := range allowedTypes {
        if ext == t {
            allowed = true
            break
        }
    }

    if !allowed {
        return ErrInvalidType
    }

    return nil
}
```

**支持类型**：

- `glb` - glTF Binary
- `glt` - 私有格式

---

### 1.2 文件存储结构

```
static/models/
  ├── 1/
  │   ├── model.glb           # 模型文件
  │   └── thumbnail.webp      # 预览图
  ├── 2/
  │   ├── model.glt           # 私有格式
  │   └── thumbnail.webp
  └── ...
```

---

### 1.3 重复检测

```go
func checkDuplicate(fileHash string) (*Model, bool, error) {
    var model Model
    err := db.Where("file_hash = ?", fileHash).First(&model).Error
    if err == gorm.ErrRecordNotFound {
        return nil, false, nil
    }
    if err != nil {
        return nil, false, err
    }
    return &model, true, nil
}
```

---

### 1.4 文件哈希计算

```go
func calculateHash(file *multipart.FileHeader) (string, error) {
    f, err := file.Open()
    if err != nil {
        return "", err
    }
    defer f.Close()

    hash := md5.New()
    if _, err := io.Copy(hash, f); err != nil {
        return "", err
    }

    return hex.EncodeToString(hash.Sum(nil)), nil
}
```

---

## 2. 文件保存

### 2.1 保存模型文件

```go
func saveModelFile(file *multipart.FileHeader, modelID uint, fileType string) (string, error) {
    // 创建目录
    dir := filepath.Join("static/models", fmt.Sprintf("%d", modelID))
    if err := os.MkdirAll(dir, 0755); err != nil {
        return "", err
    }

    // 保存文件
    filename := fmt.Sprintf("model.%s", fileType)
    filePath := filepath.Join(dir, filename)

    src, err := file.Open()
    if err != nil {
        return "", err
    }
    defer src.Close()

    dst, err := os.Create(filePath)
    if err != nil {
        return "", err
    }
    defer dst.Close()

    if _, err := io.Copy(dst, src); err != nil {
        return "", err
    }

    // 返回相对路径
    return filepath.Join("static/models", fmt.Sprintf("%d", modelID), filename), nil
}
```

---

### 2.2 保存预览图

```go
func saveThumbnail(file *multipart.FileHeader, modelID uint) (string, error) {
    dir := filepath.Join("static/models", fmt.Sprintf("%d", modelID))
    if err := os.MkdirAll(dir, 0755); err != nil {
        return "", err
    }

    filePath := filepath.Join(dir, "thumbnail.webp")

    src, err := file.Open()
    if err != nil {
        return "", err
    }
    defer src.Close()

    dst, err := os.Create(filePath)
    if err != nil {
        return "", err
    }
    defer dst.Close()

    if _, err := io.Copy(dst, src); err != nil {
        return "", err
    }

    return filepath.Join("static/models", fmt.Sprintf("%d", modelID), "thumbnail.webp"), nil
}
```

---

## 3. 上传流程实现

```go
func (s *UploadService) UploadSingle(
    modelFile, thumbnailFile *multipart.FileHeader,
    metadata UploadMetadata,
) (*Model, error) {
    // 1. 验证文件
    if err := s.validateFile(modelFile, s.config.AllowedTypes); err != nil {
        return nil, err
    }
    if err := s.validateFile(thumbnailFile, []string{"webp", "jpg", "png"}); err != nil {
        return nil, err
    }

    // 2. 计算哈希
    fileHash, err := s.calculateHash(modelFile)
    if err != nil {
        return nil, err
    }

    // 3. 检查重复
    if existing, isDup, err := s.checkDuplicate(fileHash); err != nil {
        return nil, err
    } else if isDup {
        return existing, ErrDuplicateFile
    }

    // 4. 创建模型记录（获取ID）
    model := &Model{
        Name:        metadata.Name,
        Description: metadata.Description,
        Category:    metadata.Category,
        Tags:        strings.Join(metadata.Tags, ","),
        Type:        metadata.Type,
        FileSize:    modelFile.Size,
        FileHash:    fileHash,
        UploadedBy:  metadata.UploadedBy,
        UploadIP:    metadata.UploadIP,
    }

    if err := s.db.Create(model).Error; err != nil {
        return nil, err
    }

    // 5. 保存文件
    filePath, err := s.saveModelFile(modelFile, model.ID, metadata.Type)
    if err != nil {
        s.db.Delete(model) // 回滚
        return nil, err
    }

    thumbnailPath, err := s.saveThumbnail(thumbnailFile, model.ID)
    if err != nil {
        os.RemoveAll(filepath.Dir(filePath)) // 清理文件
        s.db.Delete(model) // 回滚
        return nil, err
    }

    // 6. 更新路径
    model.FilePath = filePath
    model.ThumbnailPath = thumbnailPath
    if err := s.db.Save(model).Error; err != nil {
        return nil, err
    }

    // 7. 处理标签
    if len(metadata.Tags) > 0 {
        s.tagService.AssociateModelTags(model.ID, metadata.Tags)
    }

    return model, nil
}
```

---

## 4. 删除处理

```go
func (q *QueryService) Delete(id uint) error {
    // 1. 查询模型
    var model Model
    if err := q.db.First(&model, id).Error; err != nil {
        return err
    }

    // 2. 删除文件
    dir := filepath.Dir(model.FilePath)
    if err := os.RemoveAll(dir); err != nil {
        log.Warn("删除文件失败", err)
    }

    // 3. 删除数据库记录
    if err := q.db.Delete(&model).Error; err != nil {
        return err
    }

    // 4. 删除标签关联
    q.db.Where("model_id = ?", id).Delete(&ModelTag{})

    return nil
}
```

---

## 5. 性能优化

### 5.1 并发上传

```go
type UploadPool struct {
    workers   int
    taskQueue chan *UploadTask
    wg        sync.WaitGroup
}

func (p *UploadPool) processTask(task *UploadTask) {
    defer p.wg.Done()

    model, err := uploadService.UploadSingle(
        task.ModelFile,
        task.ThumbnailFile,
        task.Metadata,
    )

    if err != nil {
        task.Error = err
        return
    }

    task.Result = model
}
```

---

### 5.2 缓存策略

```go
// 热门模型缓存
var popularModelsCache *cache.Cache

func GetPopularModels(limit int) ([]*Model, error) {
    cacheKey := fmt.Sprintf("popular_models_%d", limit)

    if cached, found := popularModelsCache.Get(cacheKey); found {
        return cached.([]*Model), nil
    }

    var models []*Model
    err := db.Order("use_count DESC").Limit(limit).Find(&models).Error
    if err != nil {
        return nil, err
    }

    popularModelsCache.Set(cacheKey, models, 5*time.Minute)

    return models, nil
}
```

---

## 6. 错误处理

### 6.1 上传错误处理

```go
func handleUploadError(err error, file *multipart.FileHeader) error {
    switch {
    case errors.Is(err, ErrFileTooLarge):
        return fmt.Errorf("文件 %s 超过大小限制", file.Filename)
    case errors.Is(err, ErrInvalidType):
        return fmt.Errorf("文件 %s 类型不支持", file.Filename)
    case errors.Is(err, ErrDuplicateFile):
        return fmt.Errorf("文件 %s 已存在", file.Filename)
    default:
        return fmt.Errorf("上传失败: %v", err)
    }
}
```

---

## 7. 日志记录

```go
func logUpload(model *Model, duration time.Duration) {
    log.WithFields(logrus.Fields{
        "model_id":    model.ID,
        "name":        model.Name,
        "type":        model.Type,
        "file_size":   model.FileSize,
        "duration_ms": duration.Milliseconds(),
    }).Info("模型上传成功")
}

func logUploadError(fileName string, err error) {
    log.WithFields(logrus.Fields{
        "file_name": fileName,
        "error":     err.Error(),
    }).Error("模型上传失败")
}
```

---

## 8. 测试要点

### 8.1 单元测试

```go
func TestValidateFile(t *testing.T) {
    tests := []struct {
        name     string
        fileSize int64
        fileName string
        wantErr  bool
    }{
        {"valid glb", 1024, "model.glb", false},
        {"valid glt", 1024, "model.glt", false},
        {"too large", maxFileSize + 1, "model.glb", true},
        {"invalid type", 1024, "model.fbx", true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 测试逻辑
        })
    }
}
```

---

### 8.2 集成测试

```go
func TestUploadFlow(t *testing.T) {
    // 1. 准备测试文件
    modelFile := createTestFile("test.glb")
    thumbnailFile := createTestFile("test.webp")
    defer os.Remove(modelFile)
    defer os.Remove(thumbnailFile)

    // 2. 上传
    model, err := uploadService.UploadSingle(modelFile, thumbnailFile, metadata)
    assert.NoError(t, err)
    assert.NotNil(t, model)

    // 3. 验证数据库
    var dbModel Model
    err = db.First(&dbModel, model.ID).Error
    assert.NoError(t, err)

    // 4. 验证文件存在
    assert.FileExists(t, model.FilePath)
    assert.FileExists(t, model.ThumbnailPath)

    // 5. 清理
    defer uploadService.Delete(model.ID)
}
```
