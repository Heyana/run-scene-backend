# 任务管理系统

## 概述

任务管理系统负责长时间运行任务的创建、调度、执行、监控和通知。

## 核心功能

- ✅ 任务创建和持久化
- ✅ 优先级队列调度
- ✅ 并发控制
- ✅ 进度追踪
- ✅ 任务取消
- ✅ 错误重试
- ✅ 任务恢复
- ✅ 完成通知

## 任务模型

```go
// models/task.go

type Task struct {
    ID          uint           `gorm:"primarykey" json:"id"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

    // 任务信息
    Type        string         `json:"type"`        // 任务类型
    Status      string         `json:"status"`      // 状态
    Priority    int            `json:"priority"`    // 优先级 0-10

    // 输入输出
    InputFile   string         `json:"input_file"`
    OutputFile  string         `json:"output_file"`
    Options     string         `json:"options"`     // JSON

    // 进度信息
    Progress    float64        `json:"progress"`    // 0-100
    Message     string         `json:"message"`
    Error       string         `json:"error"`

    // 执行信息
    StartedAt   *time.Time     `json:"started_at"`
    CompletedAt *time.Time     `json:"completed_at"`
    Duration    int64          `json:"duration"`    // 秒

    // 重试机制
    RetryCount  int            `json:"retry_count"`
    MaxRetries  int            `json:"max_retries"`
    RetryDelay  int            `json:"retry_delay"` // 秒
    LastError   string         `json:"last_error"`

    // 断点续传
    Checkpoint  string         `json:"checkpoint"`  // JSON
    Resumable   bool           `json:"resumable"`

    // 依赖关系
    ParentTaskID *uint         `json:"parent_task_id"`
    DependsOn    string        `json:"depends_on"`  // JSON数组

    // 通知
    NotifyEmail   string       `json:"notify_email"`
    NotifyWebhook string       `json:"notify_webhook"`
    CallbackURL   string       `json:"callback_url"`

    // 关联
    UserID      uint           `json:"user_id"`
    DocumentID  uint           `json:"document_id"`
}
```

## 任务状态

```go
const (
    TaskStatusPending   = "pending"    // 等待中
    TaskStatusRunning   = "running"    // 运行中
    TaskStatusCompleted = "completed"  // 已完成
    TaskStatusFailed    = "failed"     // 失败
    TaskStatusCancelled = "cancelled"  // 已取消
    TaskStatusRetrying  = "retrying"   // 重试中
)
```

## 任务类型

```go
const (
    TaskTypeVideoPreview    = "video_preview"
    TaskTypeVideoThumbnail  = "video_thumbnail"
    TaskTypeVideoConvert    = "video_convert"
    TaskTypeImageThumbnail  = "image_thumbnail"
    TaskTypeImageConvert    = "image_convert"
    TaskTypeDocumentPreview = "document_preview"
    TaskTypeModelPreview    = "model_preview"
)
```

## 任务服务

### 核心方法

```go
type TaskService struct {
    db       *gorm.DB
    queue    *TaskQueue
    executor *TaskExecutor
    notifier *TaskNotifier
    tasks    map[uint]*TaskContext
    mu       sync.RWMutex
}

// CreateTask 创建任务
func (s *TaskService) CreateTask(task *Task) error

// StartTask 启动任务
func (s *TaskService) StartTask(taskID uint) error

// CancelTask 取消任务
func (s *TaskService) CancelTask(taskID uint) error

// RetryTask 重试任务
func (s *TaskService) RetryTask(taskID uint) error

// GetTask 获取任务
func (s *TaskService) GetTask(taskID uint) (*Task, error)

// GetTaskProgress 获取任务进度
func (s *TaskService) GetTaskProgress(taskID uint) (float64, string, error)

// ListTasks 列出任务
func (s *TaskService) ListTasks(filters TaskFilters) ([]*Task, int64, error)

// RecoverTasks 恢复未完成任务（服务启动时调用）
func (s *TaskService) RecoverTasks() error
```

## 任务队列

### 优先级队列

```go
type TaskQueue struct {
    items []*Task
    mu    sync.Mutex
}

// Push 添加任务
func (q *TaskQueue) Push(task *Task)

// Pop 取出任务（按优先级）
func (q *TaskQueue) Pop() *Task

// Peek 查看队首任务
func (q *TaskQueue) Peek() *Task

// Remove 移除任务
func (q *TaskQueue) Remove(taskID uint) bool

// Len 队列长度
func (q *TaskQueue) Len() int
```

### 优先级计算

```go
// 动态优先级 = 基础优先级 + 用户等级加成 + 等待时间加成 - 预估时长惩罚
func CalculatePriority(task *Task) int {
    priority := task.BasePriority

    // 用户等级加成
    priority += task.UserLevel * 10

    // 等待时间加成（每分钟+1）
    waitMinutes := time.Since(task.CreatedAt).Minutes()
    priority += int(waitMinutes)

    // 预估时长惩罚（大任务降低优先级）
    if task.EstimatedTime > 3600 { // 超过1小时
        priority -= 20
    }

    return priority
}
```

## 任务执行器

### 并发控制

```go
type TaskExecutor struct {
    ffmpeg      *video.FFmpeg
    imagemagick *image.ImageMagick

    // 并发控制
    maxConcurrent int
    semaphore     chan struct{}

    // 资源监控
    resourceMonitor *ResourceMonitor
}

func NewTaskExecutor(config *Config) *TaskExecutor {
    return &TaskExecutor{
        maxConcurrent: config.MaxConcurrent,
        semaphore:     make(chan struct{}, config.MaxConcurrent),
    }
}

// Execute 执行任务
func (e *TaskExecutor) Execute(ctx context.Context, taskCtx *TaskContext) error {
    // 获取信号量（限制并发）
    select {
    case e.semaphore <- struct{}{}:
        defer func() { <-e.semaphore }()
    case <-ctx.Done():
        return ctx.Err()
    }

    // 检查资源
    if !e.resourceMonitor.CanExecute(taskCtx.Task) {
        return errors.New("资源不足")
    }

    // 执行任务
    return e.executeTask(ctx, taskCtx)
}
```

### 任务上下文

```go
type TaskContext struct {
    Task      *Task
    Cancel    context.CancelFunc
    Progress  chan float64
    Message   chan string

    // 资源使用
    MemoryUsed int64
    CPUUsed    float64
}
```

## 错误重试

### 重试策略

```go
// RetryTask 重试任务
func (s *TaskService) RetryTask(taskID uint) error {
    var task Task
    if err := s.db.First(&task, taskID).Error; err != nil {
        return err
    }

    // 检查重试次数
    if task.RetryCount >= task.MaxRetries {
        return errors.New("超过最大重试次数")
    }

    // 增加重试计数
    task.RetryCount++
    task.Status = TaskStatusRetrying
    task.Error = ""

    // 延迟重试
    time.Sleep(time.Duration(task.RetryDelay) * time.Second)

    // 重新加入队列
    s.queue.Push(&task)

    return s.db.Save(&task).Error
}
```

### 可重试错误

```go
// 判断错误是否可重试
func IsRetryableError(err error) bool {
    retryableErrors := []string{
        "connection refused",
        "timeout",
        "temporary failure",
        "disk full", // 磁盘满可能是临时的
    }

    errMsg := err.Error()
    for _, retryable := range retryableErrors {
        if strings.Contains(errMsg, retryable) {
            return true
        }
    }

    return false
}
```

## 任务恢复

### 服务启动时恢复

```go
// RecoverTasks 恢复未完成任务
func (s *TaskService) RecoverTasks() error {
    var tasks []Task

    // 查找未完成的任务
    err := s.db.Where("status IN ?", []string{
        TaskStatusPending,
        TaskStatusRunning,
        TaskStatusRetrying,
    }).Find(&tasks).Error

    if err != nil {
        return err
    }

    log.Printf("发现 %d 个未完成任务，开始恢复...", len(tasks))

    for _, task := range tasks {
        // 重置状态
        task.Status = TaskStatusPending
        task.Progress = 0
        task.Message = "任务恢复中..."

        // 检查是否支持断点续传
        if task.Resumable && task.Checkpoint != "" {
            task.Message = "从断点恢复..."
        }

        // 重新加入队列
        s.queue.Push(&task)
        s.db.Save(&task)
    }

    return nil
}
```

### 断点续传

```go
// Checkpoint 检查点数据
type Checkpoint struct {
    ProcessedFrames int     `json:"processed_frames"`
    ProcessedBytes  int64   `json:"processed_bytes"`
    LastPosition    float64 `json:"last_position"`
    TempFiles       []string `json:"temp_files"`
}

// SaveCheckpoint 保存检查点
func (s *TaskService) SaveCheckpoint(taskID uint, checkpoint *Checkpoint) error {
    data, _ := json.Marshal(checkpoint)

    return s.db.Model(&Task{}).
        Where("id = ?", taskID).
        Update("checkpoint", string(data)).Error
}

// LoadCheckpoint 加载检查点
func (s *TaskService) LoadCheckpoint(taskID uint) (*Checkpoint, error) {
    var task Task
    if err := s.db.First(&task, taskID).Error; err != nil {
        return nil, err
    }

    if task.Checkpoint == "" {
        return nil, nil
    }

    var checkpoint Checkpoint
    if err := json.Unmarshal([]byte(task.Checkpoint), &checkpoint); err != nil {
        return nil, err
    }

    return &checkpoint, nil
}
```

## 资源管理

### 资源监控

```go
type ResourceMonitor struct {
    maxMemory    int64
    maxCPU       float64
    maxTempSize  int64

    currentMemory int64
    currentCPU    float64
    currentTemp   int64

    mu sync.RWMutex
}

// CanExecute 检查是否可以执行任务
func (m *ResourceMonitor) CanExecute(task *Task) bool {
    m.mu.RLock()
    defer m.mu.RUnlock()

    // 检查内存
    estimatedMemory := EstimateMemoryUsage(task)
    if m.currentMemory+estimatedMemory > m.maxMemory {
        return false
    }

    // 检查CPU
    if m.currentCPU > m.maxCPU {
        return false
    }

    // 检查临时文件空间
    estimatedTemp := EstimateTempSize(task)
    if m.currentTemp+estimatedTemp > m.maxTempSize {
        return false
    }

    return true
}

// AllocateResources 分配资源
func (m *ResourceMonitor) AllocateResources(task *Task) {
    m.mu.Lock()
    defer m.mu.Unlock()

    m.currentMemory += EstimateMemoryUsage(task)
    m.currentTemp += EstimateTempSize(task)
}

// ReleaseResources 释放资源
func (m *ResourceMonitor) ReleaseResources(task *Task) {
    m.mu.Lock()
    defer m.mu.Unlock()

    m.currentMemory -= EstimateMemoryUsage(task)
    m.currentTemp -= EstimateTempSize(task)
}
```

### 临时文件管理

```go
type TempFileManager struct {
    tempDir      string
    maxSize      int64
    cleanupAfter time.Duration

    files map[string]*TempFileInfo
    mu    sync.RWMutex
}

type TempFileInfo struct {
    Path      string
    Size      int64
    CreatedAt time.Time
    TaskID    uint
}

// CreateTempFile 创建临时文件
func (m *TempFileManager) CreateTempFile(taskID uint, prefix string) (string, error) {
    // 检查空间
    if m.GetTotalSize() >= m.maxSize {
        m.Cleanup()
    }

    // 创建临时文件
    file, err := os.CreateTemp(m.tempDir, prefix)
    if err != nil {
        return "", err
    }

    // 记录
    m.mu.Lock()
    m.files[file.Name()] = &TempFileInfo{
        Path:      file.Name(),
        CreatedAt: time.Now(),
        TaskID:    taskID,
    }
    m.mu.Unlock()

    return file.Name(), nil
}

// Cleanup 清理过期临时文件
func (m *TempFileManager) Cleanup() {
    m.mu.Lock()
    defer m.mu.Unlock()

    now := time.Now()
    for path, info := range m.files {
        if now.Sub(info.CreatedAt) > m.cleanupAfter {
            os.Remove(path)
            delete(m.files, path)
        }
    }
}
```

## 使用示例

### 创建任务

```go
task := &models.Task{
    Type:       models.TaskTypeVideoPreview,
    InputFile:  "/path/to/video.mp4",
    OutputFile: "/path/to/preview.jpg",
    Priority:   5,
    MaxRetries: 3,
    RetryDelay: 60,
    NotifyEmail: "user@example.com",
    UserID:     123,
}

err := taskService.CreateTask(task)
```

### 查询进度

```go
progress, message, err := taskService.GetTaskProgress(taskID)
fmt.Printf("进度: %.2f%%, 消息: %s\n", progress, message)
```

### 取消任务

```go
err := taskService.CancelTask(taskID)
```

### 重试任务

```go
err := taskService.RetryTask(taskID)
```
