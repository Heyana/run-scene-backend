# 处理器实现

## 概述

处理器层实现了 `FileProcessor` 接口，为不同类型的文件提供统一的处理能力。每个处理器内部调用相应的工具层封装。

## 处理器接口

```go
// services/fileprocessor/processor.go

type FileProcessor interface {
    Support(format string) bool
    ExtractMetadata(filePath string) (*FileMetadata, error)
    GeneratePreview(filePath string, options PreviewOptions) (*PreviewResult, error)
    GenerateThumbnail(filePath string, options ThumbnailOptions) (string, error)
    Convert(filePath string, options ConvertOptions) (string, error)
    Validate(filePath string) error
    Name() string
}
```

## 视频处理器

```go
// services/fileprocessor/processors/video_processor.go

package processors

import (
    "context"
    "fmt"
    "go_wails_project_manager/services/fileprocessor"
    "go_wails_project_manager/utils/video"
    "path/filepath"
)

type VideoProcessor struct {
    ffmpeg *video.FFmpeg
}

func NewVideoProcessor(ffmpeg *video.FFmpeg) *VideoProcessor {
    return &VideoProcessor{
        ffmpeg: ffmpeg,
    }
}

func (p *VideoProcessor) Name() string {
    return "VideoProcessor"
}

func (p *VideoProcessor) Support(format string) bool {
    supported := []string{
        "mp4", "avi", "mov", "webm", "mkv",
        "flv", "wmv", "m4v", "mpg", "mpeg",
    }

    for _, f := range supported {
        if f == format {
            return true
        }
    }
    return false
}

func (p *VideoProcessor) ExtractMetadata(filePath string) (*fileprocessor.FileMetadata, error) {
    videoMeta, err := p.ffmpeg.ExtractMetadata(filePath)
    if err != nil {
        return nil, err
    }

    return &fileprocessor.FileMetadata{
        FileName:  filepath.Base(filePath),
        Format:    filepath.Ext(filePath),
        Width:     videoMeta.Width,
        Height:    videoMeta.Height,
        Duration:  int64(videoMeta.Duration),
        Bitrate:   videoMeta.Bitrate,
        Codec:     videoMeta.Codec,
        FrameRate: videoMeta.FrameRate,
        FileSize:  videoMeta.FileSize,
        Extra: map[string]interface{}{
            "audio_codec":   videoMeta.AudioCodec,
            "audio_bitrate": videoMeta.AudioBitrate,
        },
    }, nil
}

func (p *VideoProcessor) GeneratePreview(filePath string, options fileprocessor.PreviewOptions) (*fileprocessor.PreviewResult, error) {
    // 生成多个时间点的预览图
    timeOffsets := []int{1, 5, 10, 30, 60} // 秒

    var previewPaths []string
    var thumbnailPath string

    for i, offset := range timeOffsets {
        outputPath := fmt.Sprintf("%s_preview_%d.jpg", options.OutputPath, i)

        err := p.ffmpeg.GenerateThumbnail(filePath, outputPath, offset)
        if err != nil {
            continue
        }

        previewPaths = append(previewPaths, outputPath)

        if i == 0 {
            thumbnailPath = outputPath
        }
    }

    if len(previewPaths) == 0 {
        return nil, fmt.Errorf("生成预览图失败")
    }

    return &fileprocessor.PreviewResult{
        ThumbnailPath: thumbnailPath,
        PreviewPaths:  previewPaths,
    }, nil
}

func (p *VideoProcessor) GenerateThumbnail(filePath string, options fileprocessor.ThumbnailOptions) (string, error) {
    err := p.ffmpeg.GenerateThumbnail(filePath, options.OutputPath, 1)
    if err != nil {
        return "", err
    }
    return options.OutputPath, nil
}

func (p *VideoProcessor) Convert(filePath string, options fileprocessor.ConvertOptions) (string, error) {
    ctx := context.Background()

    convertOpts := video.ConvertOptions{
        Codec:   options.Codec,
        Bitrate: options.Bitrate,
        Width:   options.Width,
        Height:  options.Height,
        Quality: options.Quality,
    }

    err := p.ffmpeg.Convert(ctx, filePath, options.OutputPath, convertOpts, nil)
    if err != nil {
        return "", err
    }

    return options.OutputPath, nil
}

func (p *VideoProcessor) Validate(filePath string) error {
    // 尝试提取元数据来验证文件
    _, err := p.ffmpeg.ExtractMetadata(filePath)
    return err
}
```

## 图片处理器

```go
// services/fileprocessor/processors/image_processor.go

package processors

import (
    "fmt"
    "go_wails_project_manager/services/fileprocessor"
    "go_wails_project_manager/utils/image"
    "path/filepath"
)

type ImageProcessor struct {
    imagemagick *image.ImageMagick
}

func NewImageProcessor(imagemagick *image.ImageMagick) *ImageProcessor {
    return &ImageProcessor{
        imagemagick: imagemagick,
    }
}

func (p *ImageProcessor) Name() string {
    return "ImageProcessor"
}

func (p *ImageProcessor) Support(format string) bool {
    supported := []string{
        "jpg", "jpeg", "png", "gif", "webp",
        "bmp", "tiff", "tif", "svg", "ico",
    }

    for _, f := range supported {
        if f == format {
            return true
        }
    }
    return false
}

func (p *ImageProcessor) ExtractMetadata(filePath string) (*fileprocessor.FileMetadata, error) {
    imageMeta, err := p.imagemagick.ExtractMetadata(filePath)
    if err != nil {
        return nil, err
    }

    return &fileprocessor.FileMetadata{
        FileName:  filepath.Base(filePath),
        Format:    imageMeta.Format,
        Width:     imageMeta.Width,
        Height:    imageMeta.Height,
        FileSize:  imageMeta.FileSize,
        Extra: map[string]interface{}{
            "color_space": imageMeta.ColorSpace,
            "depth":       imageMeta.Depth,
        },
    }, nil
}

func (p *ImageProcessor) GeneratePreview(filePath string, options fileprocessor.PreviewOptions) (*fileprocessor.PreviewResult, error) {
    // 生成预览图
    err := p.imagemagick.Resize(
        filePath,
        options.OutputPath,
        options.Width,
        options.Height,
        true, // 保持宽高比
    )

    if err != nil {
        return nil, err
    }

    return &fileprocessor.PreviewResult{
        ThumbnailPath: options.OutputPath,
        PreviewPaths:  []string{options.OutputPath},
    }, nil
}

func (p *ImageProcessor) GenerateThumbnail(filePath string, options fileprocessor.ThumbnailOptions) (string, error) {
    err := p.imagemagick.GenerateThumbnail(
        filePath,
        options.OutputPath,
        options.Size,
        options.Quality,
    )

    if err != nil {
        return "", err
    }

    return options.OutputPath, nil
}

func (p *ImageProcessor) Convert(filePath string, options fileprocessor.ConvertOptions) (string, error) {
    err := p.imagemagick.Convert(
        filePath,
        options.OutputPath,
        options.Format,
        options.Quality,
    )

    if err != nil {
        return "", err
    }

    return options.OutputPath, nil
}

func (p *ImageProcessor) Validate(filePath string) error {
    // 尝试提取元数据来验证文件
    _, err := p.imagemagick.ExtractMetadata(filePath)
    return err
}
```

## 文档处理器

```go
// services/fileprocessor/processors/document_processor.go

package processors

import (
    "fmt"
    "go_wails_project_manager/services/fileprocessor"
    "go_wails_project_manager/utils/document"
    "path/filepath"
)

type DocumentProcessor struct {
    pdftool *document.PDFTool
}

func NewDocumentProcessor(pdftool *document.PDFTool) *DocumentProcessor {
    return &DocumentProcessor{
        pdftool: pdftool,
    }
}

func (p *DocumentProcessor) Name() string {
    return "DocumentProcessor"
}

func (p *DocumentProcessor) Support(format string) bool {
    supported := []string{
        "pdf", "doc", "docx", "ppt", "pptx",
        "xls", "xlsx", "txt", "md",
    }

    for _, f := range supported {
        if f == format {
            return true
        }
    }
    return false
}

func (p *DocumentProcessor) ExtractMetadata(filePath string) (*fileprocessor.FileMetadata, error) {
    // 目前只支持 PDF
    ext := filepath.Ext(filePath)
    if ext != ".pdf" {
        return &fileprocessor.FileMetadata{
            FileName: filepath.Base(filePath),
            Format:   ext,
        }, nil
    }

    pdfMeta, err := p.pdftool.ExtractMetadata(filePath)
    if err != nil {
        return nil, err
    }

    return &fileprocessor.FileMetadata{
        FileName:  filepath.Base(filePath),
        Format:    "pdf",
        PageCount: pdfMeta.PageCount,
        Author:    pdfMeta.Author,
        Title:     pdfMeta.Title,
        Extra: map[string]interface{}{
            "subject": pdfMeta.Subject,
            "creator": pdfMeta.Creator,
        },
    }, nil
}

func (p *DocumentProcessor) GeneratePreview(filePath string, options fileprocessor.PreviewOptions) (*fileprocessor.PreviewResult, error) {
    // 目前只支持 PDF
    ext := filepath.Ext(filePath)
    if ext != ".pdf" {
        return nil, fmt.Errorf("不支持的文档格式: %s", ext)
    }

    // 生成前几页的预览
    maxPages := options.MaxPages
    if maxPages == 0 {
        maxPages = 5
    }

    pages := make([]int, maxPages)
    for i := 0; i < maxPages; i++ {
        pages[i] = i + 1
    }

    previewPaths, err := p.pdftool.GeneratePreview(
        filePath,
        options.OutputPath,
        pages,
        150, // DPI
    )

    if err != nil {
        return nil, err
    }

    thumbnailPath := ""
    if len(previewPaths) > 0 {
        thumbnailPath = previewPaths[0]
    }

    return &fileprocessor.PreviewResult{
        ThumbnailPath: thumbnailPath,
        PreviewPaths:  previewPaths,
    }, nil
}

func (p *DocumentProcessor) GenerateThumbnail(filePath string, options fileprocessor.ThumbnailOptions) (string, error) {
    // 生成第一页作为缩略图
    previewPaths, err := p.pdftool.GeneratePreview(
        filePath,
        options.OutputPath,
        []int{1},
        150,
    )

    if err != nil {
        return "", err
    }

    if len(previewPaths) == 0 {
        return "", fmt.Errorf("生成缩略图失败")
    }

    return previewPaths[0], nil
}

func (p *DocumentProcessor) Convert(filePath string, options fileprocessor.ConvertOptions) (string, error) {
    return "", fmt.Errorf("文档转换功能未实现")
}

func (p *DocumentProcessor) Validate(filePath string) error {
    // 尝试提取元数据来验证文件
    _, err := p.pdftool.ExtractMetadata(filePath)
    return err
}
```

## 3D模型处理器

```go
// services/fileprocessor/processors/model_processor.go

package processors

import (
    "fmt"
    "go_wails_project_manager/services/fileprocessor"
    "path/filepath"
)

type ModelProcessor struct {
    // TODO: 添加 3D 模型工具封装
}

func NewModelProcessor() *ModelProcessor {
    return &ModelProcessor{}
}

func (p *ModelProcessor) Name() string {
    return "ModelProcessor"
}

func (p *ModelProcessor) Support(format string) bool {
    supported := []string{
        "fbx", "glb", "gltf", "obj", "stl",
        "dae", "3ds", "blend",
    }

    for _, f := range supported {
        if f == format {
            return true
        }
    }
    return false
}

func (p *ModelProcessor) ExtractMetadata(filePath string) (*fileprocessor.FileMetadata, error) {
    // TODO: 实现 3D 模型元数据提取
    return &fileprocessor.FileMetadata{
        FileName: filepath.Base(filePath),
        Format:   filepath.Ext(filePath),
    }, nil
}

func (p *ModelProcessor) GeneratePreview(filePath string, options fileprocessor.PreviewOptions) (*fileprocessor.PreviewResult, error) {
    // TODO: 实现 3D 模型预览图生成
    return nil, fmt.Errorf("3D模型预览功能未实现")
}

func (p *ModelProcessor) GenerateThumbnail(filePath string, options fileprocessor.ThumbnailOptions) (string, error) {
    // TODO: 实现 3D 模型缩略图生成
    return "", fmt.Errorf("3D模型缩略图功能未实现")
}

func (p *ModelProcessor) Convert(filePath string, options fileprocessor.ConvertOptions) (string, error) {
    // TODO: 实现 3D 模型格式转换
    return "", fmt.Errorf("3D模型转换功能未实现")
}

func (p *ModelProcessor) Validate(filePath string) error {
    // TODO: 实现 3D 模型验证
    return nil
}
```

## 压缩包处理器

```go
// services/fileprocessor/processors/archive_processor.go

package processors

import (
    "archive/zip"
    "fmt"
    "go_wails_project_manager/services/fileprocessor"
    "path/filepath"
)

type ArchiveProcessor struct{}

func NewArchiveProcessor() *ArchiveProcessor {
    return &ArchiveProcessor{}
}

func (p *ArchiveProcessor) Name() string {
    return "ArchiveProcessor"
}

func (p *ArchiveProcessor) Support(format string) bool {
    supported := []string{
        "zip", "rar", "7z", "tar", "gz",
        "bz2", "xz",
    }

    for _, f := range supported {
        if f == format {
            return true
        }
    }
    return false
}

func (p *ArchiveProcessor) ExtractMetadata(filePath string) (*fileprocessor.FileMetadata, error) {
    // 目前只支持 ZIP
    ext := filepath.Ext(filePath)
    if ext != ".zip" {
        return &fileprocessor.FileMetadata{
            FileName: filepath.Base(filePath),
            Format:   ext,
        }, nil
    }

    // 打开 ZIP 文件
    r, err := zip.OpenReader(filePath)
    if err != nil {
        return nil, err
    }
    defer r.Close()

    // 统计信息
    fileCount := len(r.File)
    var totalSize int64

    for _, f := range r.File {
        totalSize += int64(f.UncompressedSize64)
    }

    return &fileprocessor.FileMetadata{
        FileName: filepath.Base(filePath),
        Format:   "zip",
        FileSize: totalSize,
        Extra: map[string]interface{}{
            "file_count":       fileCount,
            "compressed_size":  totalSize,
            "uncompressed_size": totalSize,
        },
    }, nil
}

func (p *ArchiveProcessor) GeneratePreview(filePath string, options fileprocessor.PreviewOptions) (*fileprocessor.PreviewResult, error) {
    // 压缩包没有预览图
    return nil, fmt.Errorf("压缩包不支持预览")
}

func (p *ArchiveProcessor) GenerateThumbnail(filePath string, options fileprocessor.ThumbnailOptions) (string, error) {
    // 压缩包没有缩略图
    return "", fmt.Errorf("压缩包不支持缩略图")
}

func (p *ArchiveProcessor) Convert(filePath string, options fileprocessor.ConvertOptions) (string, error) {
    // TODO: 实现压缩包格式转换
    return "", fmt.Errorf("压缩包转换功能未实现")
}

func (p *ArchiveProcessor) Validate(filePath string) error {
    // 尝试打开压缩包来验证
    ext := filepath.Ext(filePath)
    if ext != ".zip" {
        return nil
    }

    r, err := zip.OpenReader(filePath)
    if err != nil {
        return err
    }
    defer r.Close()

    return nil
}
```

## 统一服务

```go
// services/fileprocessor/file_processor_service.go

package fileprocessor

import (
    "fmt"
    "go_wails_project_manager/services/fileprocessor/processors"
    "go_wails_project_manager/utils/document"
    "go_wails_project_manager/utils/image"
    "go_wails_project_manager/utils/video"
)

type FileProcessorService struct {
    processors []FileProcessor
}

func NewFileProcessorService(config *Config) *FileProcessorService {
    service := &FileProcessorService{
        processors: make([]FileProcessor, 0),
    }

    // 初始化工具
    ffmpeg := video.NewFFmpeg(config.FFmpeg.BinPath, config.FFmpeg.Timeout)
    imagemagick := image.NewImageMagick(config.ImageMagick.BinPath, config.ImageMagick.Timeout)
    pdftool := document.NewPDFTool(config.PDF.BinPath, config.PDF.Timeout)

    // 注册处理器
    service.RegisterProcessor(processors.NewVideoProcessor(ffmpeg))
    service.RegisterProcessor(processors.NewImageProcessor(imagemagick))
    service.RegisterProcessor(processors.NewDocumentProcessor(pdftool))
    service.RegisterProcessor(processors.NewModelProcessor())
    service.RegisterProcessor(processors.NewArchiveProcessor())

    return service
}

// RegisterProcessor 注册处理器
func (s *FileProcessorService) RegisterProcessor(processor FileProcessor) {
    s.processors = append(s.processors, processor)
}

// GetProcessor 根据文件格式获取处理器
func (s *FileProcessorService) GetProcessor(format string) FileProcessor {
    for _, processor := range s.processors {
        if processor.Support(format) {
            return processor
        }
    }
    return nil
}

// ExtractMetadata 提取元数据
func (s *FileProcessorService) ExtractMetadata(filePath, format string) (*FileMetadata, error) {
    processor := s.GetProcessor(format)
    if processor == nil {
        return nil, fmt.Errorf("不支持的文件格式: %s", format)
    }
    return processor.ExtractMetadata(filePath)
}

// GeneratePreview 生成预览图
func (s *FileProcessorService) GeneratePreview(filePath, format string, options PreviewOptions) (*PreviewResult, error) {
    processor := s.GetProcessor(format)
    if processor == nil {
        return nil, fmt.Errorf("不支持的文件格式: %s", format)
    }
    return processor.GeneratePreview(filePath, options)
}

// GenerateThumbnail 生成缩略图
func (s *FileProcessorService) GenerateThumbnail(filePath, format string, options ThumbnailOptions) (string, error) {
    processor := s.GetProcessor(format)
    if processor == nil {
        return "", fmt.Errorf("不支持的文件格式: %s", format)
    }
    return processor.GenerateThumbnail(filePath, options)
}

// Convert 格式转换
func (s *FileProcessorService) Convert(filePath, format string, options ConvertOptions) (string, error) {
    processor := s.GetProcessor(format)
    if processor == nil {
        return "", fmt.Errorf("不支持的文件格式: %s", format)
    }
    return processor.Convert(filePath, options)
}

// Validate 验证文件
func (s *FileProcessorService) Validate(filePath, format string) error {
    processor := s.GetProcessor(format)
    if processor == nil {
        return fmt.Errorf("不支持的文件格式: %s", format)
    }
    return processor.Validate(filePath)
}

// ListSupportedFormats 列出支持的格式
func (s *FileProcessorService) ListSupportedFormats() map[string][]string {
    formats := make(map[string][]string)

    for _, processor := range s.processors {
        // 这里需要每个处理器提供支持的格式列表
        // 简化实现，实际应该在处理器中定义
        formats[processor.Name()] = []string{}
    }

    return formats
}
```

## 使用示例

```go
// 初始化服务
config := &fileprocessor.Config{
    FFmpeg: fileprocessor.FFmpegConfig{
        BinPath: "ffmpeg",
        Timeout: 300,
    },
    ImageMagick: fileprocessor.ImageMagickConfig{
        BinPath: "convert",
        Timeout: 60,
    },
}

service := fileprocessor.NewFileProcessorService(config)

// 提取元数据
metadata, err := service.ExtractMetadata("/path/to/video.mp4", "mp4")
if err != nil {
    log.Fatal(err)
}
fmt.Printf("分辨率: %dx%d\n", metadata.Width, metadata.Height)

// 生成预览图
options := fileprocessor.PreviewOptions{
    Width:      800,
    Height:     600,
    OutputPath: "/path/to/preview.jpg",
}
result, err := service.GeneratePreview("/path/to/video.mp4", "mp4", options)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("预览图: %v\n", result.PreviewPaths)

// 生成缩略图
thumbOptions := fileprocessor.ThumbnailOptions{
    Size:       200,
    Quality:    85,
    OutputPath: "/path/to/thumb.jpg",
}
thumbPath, err := service.GenerateThumbnail("/path/to/image.jpg", "jpg", thumbOptions)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("缩略图: %s\n", thumbPath)
```
