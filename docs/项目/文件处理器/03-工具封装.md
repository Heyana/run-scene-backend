# 工具封装

## 概述

工具层封装了底层命令行工具（FFmpeg、ImageMagick等），提供统一的 Go 接口，支持上下文取消、进度回调、错误处理等功能。

## 设计原则

1. **统一接口**: 所有工具提供一致的接口风格
2. **上下文支持**: 支持 context.Context 取消操作
3. **进度回调**: 支持实时进度更新
4. **错误详细**: 提供详细的错误信息和日志
5. **配置灵活**: 支持自定义工具路径和参数

## FFmpeg 封装

### 基础结构

```go
// utils/video/ffmpeg.go

package video

import (
    "bufio"
    "context"
    "encoding/json"
    "fmt"
    "os/exec"
    "regexp"
    "strconv"
    "strings"
    "time"
)

type FFmpeg struct {
    binPath string
    timeout time.Duration
}

func NewFFmpeg(binPath string, timeout int) *FFmpeg {
    if binPath == "" {
        binPath = "ffmpeg"
    }
    if timeout == 0 {
        timeout = 300
    }
    return &FFmpeg{
        binPath: binPath,
        timeout: time.Duration(timeout) * time.Second,
    }
}

// GetPath 获取可执行文件路径
func (f *FFmpeg) GetPath() string {
    return f.binPath
}

// CheckInstalled 检查是否已安装
func (f *FFmpeg) CheckInstalled() error {
    cmd := exec.Command(f.binPath, "-version")
    if err := cmd.Run(); err != nil {
        return fmt.Errorf("FFmpeg 未安装或路径错误: %w", err)
    }
    return nil
}
```

### 元数据提取

```go
// VideoMetadata 视频元数据
type VideoMetadata struct {
    Width       int     `json:"width"`
    Height      int     `json:"height"`
    Duration    float64 `json:"duration"`    // 秒
    Bitrate     int64   `json:"bitrate"`     // bps
    Codec       string  `json:"codec"`
    FrameRate   float64 `json:"frame_rate"`
    AudioCodec  string  `json:"audio_codec"`
    AudioBitrate int64  `json:"audio_bitrate"`
    FileSize    int64   `json:"file_size"`
}

// ExtractMetadata 提取视频元数据
func (f *FFmpeg) ExtractMetadata(filePath string) (*VideoMetadata, error) {
    // 使用 ffprobe 提取元数据
    cmd := exec.Command("ffprobe",
        "-v", "quiet",
        "-print_format", "json",
        "-show_format",
        "-show_streams",
        filePath,
    )

    output, err := cmd.Output()
    if err != nil {
        return nil, fmt.Errorf("ffprobe 执行失败: %w", err)
    }

    // 解析 JSON
    var result struct {
        Format struct {
            Duration string `json:"duration"`
            Bitrate  string `json:"bit_rate"`
            Size     string `json:"size"`
        } `json:"format"`
        Streams []struct {
            CodecType string `json:"codec_type"`
            CodecName string `json:"codec_name"`
            Width     int    `json:"width"`
            Height    int    `json:"height"`
            RFrameRate string `json:"r_frame_rate"`
            Bitrate   string `json:"bit_rate"`
        } `json:"streams"`
    }

    if err := json.Unmarshal(output, &result); err != nil {
        return nil, fmt.Errorf("解析 ffprobe 输出失败: %w", err)
    }

    metadata := &VideoMetadata{}

    // 解析时长
    if duration, err := strconv.ParseFloat(result.Format.Duration, 64); err == nil {
        metadata.Duration = duration
    }

    // 解析比特率
    if bitrate, err := strconv.ParseInt(result.Format.Bitrate, 10, 64); err == nil {
        metadata.Bitrate = bitrate
    }

    // 解析文件大小
    if size, err := strconv.ParseInt(result.Format.Size, 10, 64); err == nil {
        metadata.FileSize = size
    }

    // 解析流信息
    for _, stream := range result.Streams {
        if stream.CodecType == "video" {
            metadata.Width = stream.Width
            metadata.Height = stream.Height
            metadata.Codec = stream.CodecName

            // 解析帧率
            if parts := strings.Split(stream.RFrameRate, "/"); len(parts) == 2 {
                num, _ := strconv.ParseFloat(parts[0], 64)
                den, _ := strconv.ParseFloat(parts[1], 64)
                if den != 0 {
                    metadata.FrameRate = num / den
                }
            }
        } else if stream.CodecType == "audio" {
            metadata.AudioCodec = stream.CodecName
            if bitrate, err := strconv.ParseInt(stream.Bitrate, 10, 64); err == nil {
                metadata.AudioBitrate = bitrate
            }
        }
    }

    return metadata, nil
}
```

### 缩略图生成

```go
// GenerateThumbnail 生成缩略图（简单版本）
func (f *FFmpeg) GenerateThumbnail(input, output string, timeOffset int) error {
    cmd := exec.Command(f.binPath,
        "-i", input,
        "-ss", fmt.Sprintf("%d", timeOffset),
        "-vframes", "1",
        "-q:v", "2", // 质量
        "-y",
        output,
    )

    if err := cmd.Run(); err != nil {
        return fmt.Errorf("生成缩略图失败: %w", err)
    }

    return nil
}

// GenerateThumbnailWithContext 生成缩略图（支持取消和进度）
func (f *FFmpeg) GenerateThumbnailWithContext(
    ctx context.Context,
    input, output string,
    timeOffset int,
    progressCallback func(float64),
) error {
    cmd := exec.CommandContext(ctx, f.binPath,
        "-i", input,
        "-ss", fmt.Sprintf("%d", timeOffset),
        "-vframes", "1",
        "-q:v", "2",
        "-progress", "pipe:1", // 输出进度到 stdout
        "-y",
        output,
    )

    // 捕获输出
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        return err
    }

    stderr, err := cmd.StderrPipe()
    if err != nil {
        return err
    }

    if err := cmd.Start(); err != nil {
        return err
    }

    // 解析进度
    if progressCallback != nil {
        go f.parseProgress(stdout, progressCallback)
    }

    // 捕获错误输出
    go func() {
        scanner := bufio.NewScanner(stderr)
        for scanner.Scan() {
            // 记录错误日志
            fmt.Println("FFmpeg:", scanner.Text())
        }
    }()

    return cmd.Wait()
}

// parseProgress 解析 FFmpeg 进度输出
func (f *FFmpeg) parseProgress(reader io.Reader, callback func(float64)) {
    scanner := bufio.NewScanner(reader)

    var totalDuration float64
    var currentTime float64

    for scanner.Scan() {
        line := scanner.Text()

        // 解析总时长
        if strings.HasPrefix(line, "Duration: ") {
            re := regexp.MustCompile(`Duration: (\d+):(\d+):(\d+\.\d+)`)
            matches := re.FindStringSubmatch(line)
            if len(matches) == 4 {
                h, _ := strconv.ParseFloat(matches[1], 64)
                m, _ := strconv.ParseFloat(matches[2], 64)
                s, _ := strconv.ParseFloat(matches[3], 64)
                totalDuration = h*3600 + m*60 + s
            }
        }

        // 解析当前时间
        if strings.HasPrefix(line, "out_time_ms=") {
            timeStr := strings.TrimPrefix(line, "out_time_ms=")
            if timeMs, err := strconv.ParseInt(timeStr, 10, 64); err == nil {
                currentTime = float64(timeMs) / 1000000.0

                if totalDuration > 0 {
                    progress := (currentTime / totalDuration) * 100
                    if progress > 100 {
                        progress = 100
                    }
                    callback(progress)
                }
            }
        }
    }
}
```

### 视频转换

```go
// ConvertOptions 转换选项
type ConvertOptions struct {
    Codec      string  // 视频编码器
    Bitrate    int64   // 比特率
    Width      int     // 宽度
    Height     int     // 高度
    FrameRate  float64 // 帧率
    AudioCodec string  // 音频编码器
    Quality    int     // 质量 (0-51, 越小越好)
}

// Convert 转换视频格式
func (f *FFmpeg) Convert(
    ctx context.Context,
    input, output string,
    options ConvertOptions,
    progressCallback func(float64),
) error {
    args := []string{"-i", input}

    // 视频编码
    if options.Codec != "" {
        args = append(args, "-c:v", options.Codec)
    }

    // 比特率
    if options.Bitrate > 0 {
        args = append(args, "-b:v", fmt.Sprintf("%d", options.Bitrate))
    }

    // 分辨率
    if options.Width > 0 && options.Height > 0 {
        args = append(args, "-s", fmt.Sprintf("%dx%d", options.Width, options.Height))
    }

    // 帧率
    if options.FrameRate > 0 {
        args = append(args, "-r", fmt.Sprintf("%.2f", options.FrameRate))
    }

    // 质量
    if options.Quality > 0 {
        args = append(args, "-crf", fmt.Sprintf("%d", options.Quality))
    }

    // 音频编码
    if options.AudioCodec != "" {
        args = append(args, "-c:a", options.AudioCodec)
    }

    // 进度输出
    args = append(args, "-progress", "pipe:1")

    // 覆盖输出
    args = append(args, "-y", output)

    cmd := exec.CommandContext(ctx, f.binPath, args...)

    // 处理进度
    stdout, _ := cmd.StdoutPipe()
    if err := cmd.Start(); err != nil {
        return err
    }

    if progressCallback != nil {
        go f.parseProgress(stdout, progressCallback)
    }

    return cmd.Wait()
}
```

## ImageMagick 封装

### 基础结构

```go
// utils/image/imagemagick.go

package image

import (
    "context"
    "fmt"
    "os/exec"
    "regexp"
    "strconv"
    "strings"
)

type ImageMagick struct {
    binPath string
    timeout int
}

func NewImageMagick(binPath string, timeout int) *ImageMagick {
    if binPath == "" {
        binPath = "convert"
    }
    if timeout == 0 {
        timeout = 60
    }
    return &ImageMagick{
        binPath: binPath,
        timeout: timeout,
    }
}

// GetPath 获取可执行文件路径
func (im *ImageMagick) GetPath() string {
    return im.binPath
}

// CheckInstalled 检查是否已安装
func (im *ImageMagick) CheckInstalled() error {
    cmd := exec.Command(im.binPath, "-version")
    if err := cmd.Run(); err != nil {
        return fmt.Errorf("ImageMagick 未安装或路径错误: %w", err)
    }
    return nil
}
```

### 元数据提取

```go
// ImageMetadata 图片元数据
type ImageMetadata struct {
    Width    int    `json:"width"`
    Height   int    `json:"height"`
    Format   string `json:"format"`
    FileSize int64  `json:"file_size"`
    ColorSpace string `json:"color_space"`
    Depth    int    `json:"depth"`
}

// ExtractMetadata 提取图片元数据
func (im *ImageMagick) ExtractMetadata(filePath string) (*ImageMetadata, error) {
    // identify -format "%w %h %b %m %[colorspace] %z" input.jpg
    cmd := exec.Command("identify",
        "-format", "%w %h %b %m %[colorspace] %z",
        filePath,
    )

    output, err := cmd.Output()
    if err != nil {
        return nil, fmt.Errorf("identify 执行失败: %w", err)
    }

    // 解析输出
    parts := strings.Fields(string(output))
    if len(parts) < 6 {
        return nil, fmt.Errorf("identify 输出格式错误")
    }

    metadata := &ImageMetadata{}

    // 宽度
    metadata.Width, _ = strconv.Atoi(parts[0])

    // 高度
    metadata.Height, _ = strconv.Atoi(parts[1])

    // 文件大小
    sizeStr := parts[2]
    if strings.HasSuffix(sizeStr, "KB") {
        size, _ := strconv.ParseFloat(strings.TrimSuffix(sizeStr, "KB"), 64)
        metadata.FileSize = int64(size * 1024)
    } else if strings.HasSuffix(sizeStr, "MB") {
        size, _ := strconv.ParseFloat(strings.TrimSuffix(sizeStr, "MB"), 64)
        metadata.FileSize = int64(size * 1024 * 1024)
    }

    // 格式
    metadata.Format = parts[3]

    // 色彩空间
    metadata.ColorSpace = parts[4]

    // 位深度
    metadata.Depth, _ = strconv.Atoi(parts[5])

    return metadata, nil
}
```

### 图片处理

```go
// Resize 调整大小
func (im *ImageMagick) Resize(input, output string, width, height int, keepAspect bool) error {
    sizeStr := fmt.Sprintf("%dx%d", width, height)
    if keepAspect {
        sizeStr += ">" // 保持宽高比，不放大
    } else {
        sizeStr += "!" // 强制调整到指定大小
    }

    cmd := exec.Command(im.binPath,
        input,
        "-resize", sizeStr,
        output,
    )

    return cmd.Run()
}

// Convert 转换格式
func (im *ImageMagick) Convert(input, output string, format string, quality int) error {
    args := []string{input}

    // 质量
    if quality > 0 {
        args = append(args, "-quality", fmt.Sprintf("%d", quality))
    }

    // 输出格式
    if format != "" {
        args = append(args, "-format", format)
    }

    args = append(args, output)

    cmd := exec.Command(im.binPath, args...)
    return cmd.Run()
}

// GenerateThumbnail 生成缩略图（正方形，居中裁剪）
func (im *ImageMagick) GenerateThumbnail(input, output string, size int, quality int) error {
    cmd := exec.Command(im.binPath,
        input,
        "-thumbnail", fmt.Sprintf("%dx%d^", size, size), // ^ 表示填充
        "-gravity", "center",                             // 居中
        "-extent", fmt.Sprintf("%dx%d", size, size),     // 裁剪
        "-quality", fmt.Sprintf("%d", quality),
        output,
    )

    return cmd.Run()
}

// Crop 裁剪图片
func (im *ImageMagick) Crop(input, output string, x, y, width, height int) error {
    cmd := exec.Command(im.binPath,
        input,
        "-crop", fmt.Sprintf("%dx%d+%d+%d", width, height, x, y),
        "+repage", // 重置画布
        output,
    )

    return cmd.Run()
}

// Rotate 旋转图片
func (im *ImageMagick) Rotate(input, output string, angle int) error {
    cmd := exec.Command(im.binPath,
        input,
        "-rotate", fmt.Sprintf("%d", angle),
        output,
    )

    return cmd.Run()
}

// AddWatermark 添加水印
func (im *ImageMagick) AddWatermark(input, watermark, output string, position string, opacity int) error {
    // position: NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast
    cmd := exec.Command(im.binPath,
        input,
        watermark,
        "-gravity", position,
        "-compose", "over",
        "-define", fmt.Sprintf("compose:args=%d", opacity),
        "-composite",
        output,
    )

    return cmd.Run()
}
```

## PDF 工具封装

### 基础结构

```go
// utils/document/pdf.go

package document

import (
    "fmt"
    "os/exec"
    "strconv"
    "strings"
)

type PDFTool struct {
    binPath string
    timeout int
}

func NewPDFTool(binPath string, timeout int) *PDFTool {
    if binPath == "" {
        binPath = "pdftoppm"
    }
    if timeout == 0 {
        timeout = 120
    }
    return &PDFTool{
        binPath: binPath,
        timeout: timeout,
    }
}
```

### PDF 处理

```go
// PDFMetadata PDF 元数据
type PDFMetadata struct {
    PageCount int    `json:"page_count"`
    Title     string `json:"title"`
    Author    string `json:"author"`
    Subject   string `json:"subject"`
    Creator   string `json:"creator"`
}

// ExtractMetadata 提取 PDF 元数据
func (p *PDFTool) ExtractMetadata(filePath string) (*PDFMetadata, error) {
    // pdfinfo input.pdf
    cmd := exec.Command("pdfinfo", filePath)
    output, err := cmd.Output()
    if err != nil {
        return nil, fmt.Errorf("pdfinfo 执行失败: %w", err)
    }

    metadata := &PDFMetadata{}
    lines := strings.Split(string(output), "\n")

    for _, line := range lines {
        parts := strings.SplitN(line, ":", 2)
        if len(parts) != 2 {
            continue
        }

        key := strings.TrimSpace(parts[0])
        value := strings.TrimSpace(parts[1])

        switch key {
        case "Pages":
            metadata.PageCount, _ = strconv.Atoi(value)
        case "Title":
            metadata.Title = value
        case "Author":
            metadata.Author = value
        case "Subject":
            metadata.Subject = value
        case "Creator":
            metadata.Creator = value
        }
    }

    return metadata, nil
}

// GeneratePreview 生成 PDF 预览图
func (p *PDFTool) GeneratePreview(input, outputPrefix string, pages []int, dpi int) ([]string, error) {
    // pdftoppm -png -r 150 -f 1 -l 5 input.pdf output
    args := []string{
        "-png",
        "-r", fmt.Sprintf("%d", dpi),
    }

    if len(pages) > 0 {
        args = append(args, "-f", fmt.Sprintf("%d", pages[0]))
        args = append(args, "-l", fmt.Sprintf("%d", pages[len(pages)-1]))
    }

    args = append(args, input, outputPrefix)

    cmd := exec.Command(p.binPath, args...)
    if err := cmd.Run(); err != nil {
        return nil, fmt.Errorf("生成预览失败: %w", err)
    }

    // 返回生成的文件列表
    var outputs []string
    for _, page := range pages {
        outputs = append(outputs, fmt.Sprintf("%s-%d.png", outputPrefix, page))
    }

    return outputs, nil
}
```

## 工具管理器

### 统一管理

```go
// utils/toolmanager.go

package utils

type ToolManager struct {
    ffmpeg      *video.FFmpeg
    imagemagick *image.ImageMagick
    pdftool     *document.PDFTool
}

func NewToolManager(config *Config) *ToolManager {
    return &ToolManager{
        ffmpeg:      video.NewFFmpeg(config.FFmpeg.BinPath, config.FFmpeg.Timeout),
        imagemagick: image.NewImageMagick(config.ImageMagick.BinPath, config.ImageMagick.Timeout),
        pdftool:     document.NewPDFTool(config.PDF.BinPath, config.PDF.Timeout),
    }
}

// CheckAll 检查所有工具是否已安装
func (tm *ToolManager) CheckAll() map[string]error {
    results := make(map[string]error)

    results["ffmpeg"] = tm.ffmpeg.CheckInstalled()
    results["imagemagick"] = tm.imagemagick.CheckInstalled()
    results["pdftool"] = tm.pdftool.CheckInstalled()

    return results
}

// GetFFmpeg 获取 FFmpeg 实例
func (tm *ToolManager) GetFFmpeg() *video.FFmpeg {
    return tm.ffmpeg
}

// GetImageMagick 获取 ImageMagick 实例
func (tm *ToolManager) GetImageMagick() *image.ImageMagick {
    return tm.imagemagick
}

// GetPDFTool 获取 PDF 工具实例
func (tm *ToolManager) GetPDFTool() *document.PDFTool {
    return tm.pdftool
}
```

## 错误处理

### 工具错误

```go
// ToolError 工具错误
type ToolError struct {
    Tool    string
    Command string
    Args    []string
    Output  string
    Err     error
}

func (e *ToolError) Error() string {
    return fmt.Sprintf("%s 执行失败: %v\n命令: %s %s\n输出: %s",
        e.Tool, e.Err, e.Command, strings.Join(e.Args, " "), e.Output)
}

// WrapToolError 包装工具错误
func WrapToolError(tool, command string, args []string, output string, err error) error {
    return &ToolError{
        Tool:    tool,
        Command: command,
        Args:    args,
        Output:  output,
        Err:     err,
    }
}
```

## 使用示例

### FFmpeg 使用

```go
ffmpeg := video.NewFFmpeg("", 0)

// 提取元数据
metadata, err := ffmpeg.ExtractMetadata("video.mp4")
fmt.Printf("分辨率: %dx%d, 时长: %.2f秒\n", metadata.Width, metadata.Height, metadata.Duration)

// 生成缩略图
err = ffmpeg.GenerateThumbnail("video.mp4", "thumb.jpg", 5)

// 转换视频（带进度）
ctx := context.Background()
err = ffmpeg.Convert(ctx, "input.mp4", "output.webm", video.ConvertOptions{
    Codec:   "libvpx-vp9",
    Bitrate: 2000000,
    Quality: 30,
}, func(progress float64) {
    fmt.Printf("进度: %.2f%%\n", progress)
})
```

### ImageMagick 使用

```go
im := image.NewImageMagick("", 0)

// 提取元数据
metadata, err := im.ExtractMetadata("image.jpg")
fmt.Printf("分辨率: %dx%d\n", metadata.Width, metadata.Height)

// 生成缩略图
err = im.GenerateThumbnail("image.jpg", "thumb.jpg", 200, 85)

// 调整大小
err = im.Resize("image.jpg", "resized.jpg", 800, 600, true)

// 添加水印
err = im.AddWatermark("image.jpg", "watermark.png", "output.jpg", "SouthEast", 50)
```
