# 文件库存储优化方案

## 当前问题

单个文件夹存储所有文件，可能导致：

- 单目录文件过多（性能下降）
- 难以管理和清理
- 备份和迁移困难

## 优化方案对比

### 方案 A：按年月日存储（推荐）

**路径结构**：

```
documents/
├── 2026/
│   ├── 02/
│   │   ├── 09/
│   │   │   ├── 1/file.pdf
│   │   │   ├── 2/file.mp4
│   │   │   └── 3/file.zip
│   │   └── 10/
│   │       └── 4/file.docx
│   └── 03/
│       └── 01/
│           └── 5/file.xlsx
```

**优点**：

- 文件分散均匀
- 易于按日期清理
- 便于备份特定时间段
- 目录结构清晰

**缺点**：

- 目录层级较深（4层）

**实现**：

```go
yearMonthDay := time.Now().Format("2006/01/02")
subPath := filepath.Join(yearMonthDay, fmt.Sprintf("%d", documentID))
```

### 方案 B：按年月存储

**路径结构**：

```
documents/
├── 2026/
│   ├── 02/
│   │   ├── 1/file.pdf
│   │   ├── 2/file.mp4
│   │   └── ...
│   └── 03/
│       └── 100/file.docx
```

**优点**：

- 目录层级适中（3层）
- 按月管理方便

**缺点**：

- 单月文件可能较多（日均100个 = 月3000个）

**实现**：

```go
yearMonth := time.Now().Format("2006/01")
subPath := filepath.Join(yearMonth, fmt.Sprintf("%d", documentID))
```

### 方案 C：按 ID 分片存储

**路径结构**：

```
documents/
├── 0/
│   ├── 1/file.pdf
│   ├── 2/file.mp4
│   └── 999/file.zip
├── 1/
│   ├── 1000/file.docx
│   └── 1999/file.xlsx
```

**优点**：

- 查询快（直接计算路径）
- 分布均匀
- 性能最优

**缺点**：

- 不直观
- 难以按时间清理
- 不便于人工管理

**实现**：

```go
shard := documentID / 1000
subPath := filepath.Join(fmt.Sprintf("%d", shard), fmt.Sprintf("%d", documentID))
```

## 推荐方案：按年月日存储

### 理由

1. **文件量预估**：
   - 日均上传：10-50 个文件
   - 月均上传：300-1500 个文件
   - 年均上传：3600-18000 个文件

2. **管理需求**：
   - 需要按时间清理旧文件
   - 需要按时间段备份
   - 需要人工查看和管理

3. **性能考虑**：
   - 单日文件数：10-50（完全可接受）
   - 目录层级：4层（可接受）
   - 查询性能：数据库索引 + 路径拼接（快速）

### 实现代码

```go
// services/document/upload_service.go

// saveFile 保存文件到存储（优化版）
func (s *UploadService) saveFile(file *multipart.FileHeader, documentID uint) (string, error) {
	// 读取文件数据
	src, err := file.Open()
	if err != nil {
		return "", fmt.Errorf("打开上传文件失败: %w", err)
	}
	defer src.Close()

	data, err := io.ReadAll(src)
	if err != nil {
		return "", fmt.Errorf("读取文件数据失败: %w", err)
	}

	// 确定文件名
	ext := filepath.Ext(file.Filename)
	fileName := "file" + ext

	// 使用年月日分组
	yearMonthDay := time.Now().Format("2006/01/02")
	subPath := filepath.Join(yearMonthDay, fmt.Sprintf("%d", documentID))

	return s.storageService.SaveFile(subPath, fileName, data)
}
```

### 文件夹上传支持

```go
// UploadFolder 上传文件夹
func (s *UploadService) UploadFolder(files []*multipart.FileHeader, filePaths []string, metadata UploadMetadata) (*models.Document, error) {
	// 1. 创建文档记录（代表整个文件夹）
	document := &models.Document{
		Name:        metadata.Name,
		Description: metadata.Description,
		Type:        models.TypeArchive, // 文件夹类型
		// ...
	}

	if err := s.db.Create(document).Error; err != nil {
		return nil, err
	}

	// 2. 使用年月日分组
	yearMonthDay := time.Now().Format("2006/01/02")
	baseSubPath := filepath.Join(yearMonthDay, fmt.Sprintf("%d", document.ID))

	// 3. 保存所有文件，保持相对路径
	for i, file := range files {
		relativePath := filePaths[i]

		// 读取文件数据
		src, _ := file.Open()
		data, _ := io.ReadAll(src)
		src.Close()

		// 保存文件，保持目录结构
		subPath := filepath.Join(baseSubPath, filepath.Dir(relativePath))
		fileName := filepath.Base(relativePath)

		s.storageService.SaveFile(subPath, fileName, data)
	}

	// 4. 更新文档路径
	document.FilePath = baseSubPath
	s.db.Save(document)

	return document, nil
}
```

## 迁移方案

### 1. 新文件使用新路径

```go
// 配置中添加开关
type DocumentConfig struct {
	UseTimePath bool `yaml:"use_time_path"` // 是否使用时间路径
}

// 上传时判断
func (s *UploadService) saveFile(...) {
	var subPath string
	if s.config.UseTimePath {
		yearMonthDay := time.Now().Format("2006/01/02")
		subPath = filepath.Join(yearMonthDay, fmt.Sprintf("%d", documentID))
	} else {
		subPath = fmt.Sprintf("%d", documentID)
	}
	// ...
}
```

### 2. 旧文件保持不变

- AfterFind 钩子自动兼容新旧路径
- 不需要迁移旧文件
- 逐步过渡

## 性能测试

### 单目录文件数 vs 性能

| 文件数     | 列表性能 | 查找性能 | 备注     |
| ---------- | -------- | -------- | -------- |
| < 1000     | 优秀     | 优秀     | 无影响   |
| 1000-5000  | 良好     | 良好     | 轻微影响 |
| 5000-10000 | 一般     | 一般     | 明显影响 |
| > 10000    | 较差     | 较差     | 需要优化 |

### 按年月日存储

- 日均 50 个文件
- 单日目录：50 个子目录
- 性能：优秀 ✅

## 总结

**推荐使用按年月日存储**：

- 路径：`documents/2026/02/09/123/file.pdf`
- 优点：分散均匀、易于管理、便于清理
- 缺点：目录层级稍深（可接受）
- 适用场景：文件库、资产库等需要长期存储的场景
